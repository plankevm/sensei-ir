//! REVM integration tests for IR to EVM translation
//!
//! These tests verify that our generated bytecode executes correctly in REVM.

#[cfg(test)]
mod tests {
    use crate::{Translator, test_helpers::create_simple_program};
    use eth_ir_data::{LocalId, LocalIndex, operation::*};
    use evm_glue::assembler::assemble_minimized;
    use revm::{
        Evm, InMemoryDB,
        primitives::{Bytecode, ExecutionResult, TransactTo, U256, address},
    };

    /// Helper to setup and execute bytecode in REVM
    pub(super) fn execute_bytecode(bytecode: Vec<u8>, calldata: Vec<u8>) -> ExecutionResult {
        let mut db = InMemoryDB::default();
        let contract_addr = address!("1000000000000000000000000000000000000000");
        let caller_addr = address!("9000000000000000000000000000000000000000");

        // Deploy contract
        db.insert_account_info(
            contract_addr,
            revm::primitives::AccountInfo {
                balance: U256::ZERO,
                nonce: 0,
                code_hash: revm::primitives::keccak256(&bytecode),
                code: Some(Bytecode::new_raw(bytecode.into())),
            },
        );

        // Fund caller
        db.insert_account_info(
            caller_addr,
            revm::primitives::AccountInfo {
                balance: U256::from(1_000_000_000_000_000_000u64), // 1 ETH
                nonce: 0,
                code_hash: revm::primitives::KECCAK_EMPTY,
                code: None,
            },
        );

        // Execute
        let mut evm = Evm::builder()
            .with_db(db)
            .modify_tx_env(|tx| {
                tx.caller = caller_addr;
                tx.gas_limit = 1_000_000;
                tx.gas_price = U256::from(1);
                tx.transact_to = TransactTo::Call(contract_addr);
                tx.value = U256::ZERO;
                tx.data = calldata.into();
            })
            .build();

        evm.transact_commit().expect("Transaction should succeed")
    }

    /// Helper to translate IR program to bytecode
    pub(super) fn ir_to_bytecode(program: eth_ir_data::EthIRProgram) -> Vec<u8> {
        let mut translator = Translator::new(program);
        translator.translate().expect("Translation should succeed");
        let assembly = translator.into_asm();
        let (_marks, bytecode) =
            assemble_minimized(&assembly, true).expect("Assembly should succeed");
        bytecode
    }

    /// Helper to validate execution results with Return operation
    fn validate_return_value(result: &ExecutionResult, expected: U256, description: &str) {
        match result {
            ExecutionResult::Success { output, .. } => {
                let bytes = match output {
                    revm::primitives::Output::Call(b) => b,
                    revm::primitives::Output::Create(b, _) => b,
                };
                assert_eq!(
                    bytes.len(),
                    32,
                    "Expected 32 bytes for {}, got {}",
                    description,
                    bytes.len()
                );
                let actual = U256::from_be_slice(&bytes);
                assert_eq!(
                    actual, expected,
                    "Failed validation for {}: expected {}, got {}",
                    description, expected, actual
                );
            }
            _ => panic!("Execution failed when validating {}", description),
        }
    }

    #[test]
    fn test_ir_simple_constant() {
        // Test that our IR translator can handle simple constants
        let program = create_simple_program(vec![
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(0), value: 100 }),
            Operation::Stop,
        ]);

        let bytecode = ir_to_bytecode(program);
        println!("IR constant bytecode ({} bytes): {:02x?}", bytecode.len(), bytecode);

        let result = execute_bytecode(bytecode, vec![]);

        // Should execute without reverting
        match result {
            ExecutionResult::Success { gas_used, .. } => {
                println!("IR execution succeeded, gas used: {}", gas_used);
            }
            _ => panic!("IR execution failed: {:?}", result),
        }
    }

    #[test]
    fn test_ir_arithmetic() {
        // Test arithmetic operations including signed operations
        let program = create_simple_program(vec![
            // Setup values for AddMod/MulMod in contiguous locals
            // local0 = 20 (first operand)
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(0), value: 20 }),
            // local1 = 22 (second operand)
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(1), value: 22 }),
            // local2 = 10 (modulus for AddMod)
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(2), value: 10 }),
            // local3 = (20 + 22) % 10 = 2 (AddMod)
            Operation::AddMod(LargeInOneOut::<3> {
                args_start: LocalIndex::new(0), // uses contiguous locals 0, 1, 2
                result: LocalId::new(3),
            }),
            // Setup for MulMod with contiguous locals
            // local4 = 20 (first operand)
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(4), value: 20 }),
            // local5 = 22 (second operand)
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(5), value: 22 }),
            // local6 = 100 (modulus)
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(6), value: 100 }),
            // local7 = (20 * 22) % 100 = 40 (MulMod)
            Operation::MulMod(LargeInOneOut::<3> {
                args_start: LocalIndex::new(4), // uses contiguous locals 4, 5, 6
                result: LocalId::new(7),
            }),
            // Basic arithmetic operations
            // local8 = local0 + local1 = 42
            Operation::Add(TwoInOneOut {
                arg1: LocalId::new(0),
                arg2: LocalId::new(1),
                result: LocalId::new(8),
            }),
            // local9 = local8 - local0 = 22
            Operation::Sub(TwoInOneOut {
                arg1: LocalId::new(8),
                arg2: LocalId::new(0),
                result: LocalId::new(9),
            }),
            // local10 = 2 (for division/modulo ops)
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(10), value: 2 }),
            // local11 = local0 * 2 = 40
            Operation::Mul(TwoInOneOut {
                arg1: LocalId::new(0),
                arg2: LocalId::new(10),
                result: LocalId::new(11),
            }),
            // local12 = local8 / 2 = 21
            Operation::Div(TwoInOneOut {
                arg1: LocalId::new(8),
                arg2: LocalId::new(10),
                result: LocalId::new(12),
            }),
            // local13 = local8 % 10 = 2
            Operation::Mod(TwoInOneOut {
                arg1: LocalId::new(8),
                arg2: LocalId::new(2), // reuse local2 which has value 10
                result: LocalId::new(13),
            }),
            // local14 = 3 (exponent)
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(14), value: 3 }),
            // local15 = 2^3 = 8
            Operation::Exp(TwoInOneOut {
                arg1: LocalId::new(10), // 2
                arg2: LocalId::new(14), // 3
                result: LocalId::new(15),
            }),
            // Test signed operations
            // Note: Using small constants for negative numbers - they will be sign-extended by EVM
            // operations local16 = 0xFB (will be treated as -5 in signed context)
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(16), value: 0xFB }),
            // local17 = 0xF6 (will be treated as -10 in signed context)
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(17), value: 0xF6 }),
            // local18 = -10 / -5 = 2 (SDiv)
            Operation::SDiv(TwoInOneOut {
                arg1: LocalId::new(17), // -10
                arg2: LocalId::new(16), // -5
                result: LocalId::new(18),
            }),
            // local19 = 0xFD (will be treated as -3 in signed context)
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(19), value: 0xFD }),
            // local20 = -10 % -3 = -1 (SMod)
            Operation::SMod(TwoInOneOut {
                arg1: LocalId::new(17), // -10
                arg2: LocalId::new(19), // -3
                result: LocalId::new(20),
            }),
            // Test SignExtend: sign extend byte 0xFB to full word
            // local21 = 0 (byte position)
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(21), value: 0 }),
            Operation::SignExtend(TwoInOneOut {
                arg1: LocalId::new(21), // byte position 0
                arg2: LocalId::new(16), // 0xFB
                result: LocalId::new(22),
            }),
            Operation::Stop,
        ]);

        let bytecode = ir_to_bytecode(program);
        println!("IR arithmetic bytecode ({} bytes): {:02x?}", bytecode.len(), bytecode);

        let result = execute_bytecode(bytecode, vec![]);

        match result {
            ExecutionResult::Success { gas_used, .. } => {
                println!("Arithmetic execution succeeded, gas used: {}", gas_used);
            }
            _ => panic!("Arithmetic execution failed: {:?}", result),
        }
    }

    #[test]
    fn test_ir_storage() {
        // Test storage operations
        let program = create_simple_program(vec![
            // Set slot = 5
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(0), value: 5 }),
            // Set value = 999
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(1), value: 999 }),
            // Store value at slot
            Operation::SStore(TwoInZeroOut {
                arg1: LocalId::new(0), // slot
                arg2: LocalId::new(1), // value
            }),
            // Load from slot
            Operation::SLoad(OneInOneOut {
                arg1: LocalId::new(0),   // slot
                result: LocalId::new(2), // result
            }),
            Operation::Stop,
        ]);

        let bytecode = ir_to_bytecode(program);
        println!("IR storage bytecode ({} bytes): {:02x?}", bytecode.len(), bytecode);

        let result = execute_bytecode(bytecode, vec![]);

        match result {
            ExecutionResult::Success { gas_used, .. } => {
                println!("Storage execution succeeded, gas used: {}", gas_used);
                // Storage operations should consume gas
                assert!(gas_used > 0, "Storage operations should consume gas");
                // SSTORE typically uses at least 20000 gas in most cases, but this can vary
                // For a more robust test, we could compare relative gas costs
            }
            _ => panic!("Storage execution failed: {:?}", result),
        }
    }

    #[test]
    fn test_ir_comparison() {
        // Test comparison operations including signed comparisons
        let program = create_simple_program(vec![
            // Set local0 = 10
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(0), value: 10 }),
            // Set local1 = 20
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(1), value: 20 }),
            // local2 = (local0 < local1) = 1 (Lt)
            Operation::Lt(TwoInOneOut {
                arg1: LocalId::new(0),
                arg2: LocalId::new(1),
                result: LocalId::new(2),
            }),
            // local3 = (local0 > local1) = 0 (Gt)
            Operation::Gt(TwoInOneOut {
                arg1: LocalId::new(0),
                arg2: LocalId::new(1),
                result: LocalId::new(3),
            }),
            // local4 = (local0 == local1) = 0 (Eq)
            Operation::Eq(TwoInOneOut {
                arg1: LocalId::new(0),
                arg2: LocalId::new(1),
                result: LocalId::new(4),
            }),
            // local5 = (local0 == local0) = 1 (Eq true case)
            Operation::Eq(TwoInOneOut {
                arg1: LocalId::new(0),
                arg2: LocalId::new(0),
                result: LocalId::new(5),
            }),
            // local6 = IsZero(0) = 1
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(6), value: 0 }),
            Operation::IsZero(OneInOneOut { arg1: LocalId::new(6), result: LocalId::new(7) }),
            // local8 = IsZero(10) = 0
            Operation::IsZero(OneInOneOut { arg1: LocalId::new(0), result: LocalId::new(8) }),
            // Test signed comparisons with negative numbers
            // local9 = -5 (0xFF...FB)
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(9), value: 0xFB }),
            // local10 = -10 (0xFF...F6)
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(10), value: 0xF6 }),
            // local11 = (-10 < -5) signed = 1 (SLt)
            Operation::SLt(TwoInOneOut {
                arg1: LocalId::new(10), // -10
                arg2: LocalId::new(9),  // -5
                result: LocalId::new(11),
            }),
            // local12 = (-5 > -10) signed = 1 (SGt)
            Operation::SGt(TwoInOneOut {
                arg1: LocalId::new(9),  // -5
                arg2: LocalId::new(10), // -10
                result: LocalId::new(12),
            }),
            // local13 = (10 < -5) unsigned = 1 (because 0xFB > 10 when unsigned)
            Operation::Lt(TwoInOneOut {
                arg1: LocalId::new(0), // 10
                arg2: LocalId::new(9), // 0xFB (251 unsigned)
                result: LocalId::new(13),
            }),
            Operation::Stop,
        ]);

        let bytecode = ir_to_bytecode(program);
        println!("IR comparison bytecode ({} bytes): {:02x?}", bytecode.len(), bytecode);

        let result = execute_bytecode(bytecode, vec![]);

        match result {
            ExecutionResult::Success { gas_used, .. } => {
                println!("Comparison execution succeeded, gas used: {}", gas_used);
            }
            _ => panic!("Comparison execution failed: {:?}", result),
        }
    }

    #[test]
    fn test_ir_bitwise() {
        // Test bitwise and shift operations
        let program = create_simple_program(vec![
            // Set local0 = 0xFF (255)
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(0), value: 0xFF }),
            // Set local1 = 0x0F (15)
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(1), value: 0x0F }),
            // local2 = local0 AND local1 = 0x0F
            Operation::And(TwoInOneOut {
                arg1: LocalId::new(0),
                arg2: LocalId::new(1),
                result: LocalId::new(2),
            }),
            // local3 = local0 OR local1 = 0xFF
            Operation::Or(TwoInOneOut {
                arg1: LocalId::new(0),
                arg2: LocalId::new(1),
                result: LocalId::new(3),
            }),
            // local4 = local0 XOR local1 = 0xF0
            Operation::Xor(TwoInOneOut {
                arg1: LocalId::new(0),
                arg2: LocalId::new(1),
                result: LocalId::new(4),
            }),
            // local5 = NOT local1 = 0xFF...F0
            Operation::Not(OneInOneOut { arg1: LocalId::new(1), result: LocalId::new(5) }),
            // Test Byte operation: extract byte at position 31 from 0xFF
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(6), value: 31 }),
            Operation::Byte(TwoInOneOut {
                arg1: LocalId::new(6), // byte position 31 (rightmost)
                arg2: LocalId::new(0), // value 0xFF
                result: LocalId::new(7),
            }),
            // Test shift operations
            // local8 = 4 (shift amount)
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(8), value: 4 }),
            // local9 = 0x0F << 4 = 0xF0 (Shl)
            Operation::Shl(TwoInOneOut {
                arg1: LocalId::new(8), // shift amount
                arg2: LocalId::new(1), // value 0x0F
                result: LocalId::new(9),
            }),
            // local10 = 0xFF >> 4 = 0x0F (Shr)
            Operation::Shr(TwoInOneOut {
                arg1: LocalId::new(8), // shift amount
                arg2: LocalId::new(0), // value 0xFF
                result: LocalId::new(10),
            }),
            // Test arithmetic shift with negative number
            // local11 = -16 (0xFF...F0)
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(11), value: 0xF0 }),
            // local12 = -16 >> 4 (arithmetic) = -1 (0xFF...FF) (Sar)
            Operation::Sar(TwoInOneOut {
                arg1: LocalId::new(8),  // shift amount
                arg2: LocalId::new(11), // value -16
                result: LocalId::new(12),
            }),
            Operation::Stop,
        ]);

        let bytecode = ir_to_bytecode(program);
        println!("IR bitwise bytecode ({} bytes): {:02x?}", bytecode.len(), bytecode);

        let result = execute_bytecode(bytecode, vec![]);

        match result {
            ExecutionResult::Success { gas_used, .. } => {
                println!("Bitwise execution succeeded, gas used: {}", gas_used);
            }
            _ => panic!("Bitwise execution failed: {:?}", result),
        }
    }

    #[test]
    fn test_ir_memory_operations() {
        // Test memory copy operations
        let program = create_simple_program(vec![
            // Set local0 = 42 (value to store)
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(0), value: 42 }),
            // Set local1 = 0 (source offset)
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(1), value: 0 }),
            // Set local2 = 32 (dest offset)
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(2), value: 32 }),
            // Set local3 = 32 (length)
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(3), value: 32 }),
            // MCopy from offset 0 to offset 32, length 32
            Operation::MCopy(ThreeInZeroOut {
                arg1: LocalId::new(2), // dest
                arg2: LocalId::new(1), // source
                arg3: LocalId::new(3), // length
            }),
            Operation::Stop,
        ]);

        let bytecode = ir_to_bytecode(program);
        println!("IR memory bytecode ({} bytes): {:02x?}", bytecode.len(), bytecode);

        let result = execute_bytecode(bytecode, vec![]);

        match result {
            ExecutionResult::Success { gas_used, .. } => {
                println!("Memory ops execution succeeded, gas used: {}", gas_used);
            }
            _ => panic!("Memory ops execution failed: {:?}", result),
        }
    }

    #[test]
    fn test_ir_environmental_info() {
        // Test environmental and block information operations
        let program = create_simple_program(vec![
            // Environmental info
            Operation::Caller(ZeroInOneOut { result: LocalId::new(0) }),
            Operation::Address(ZeroInOneOut { result: LocalId::new(1) }),
            Operation::CallValue(ZeroInOneOut { result: LocalId::new(2) }),
            Operation::Origin(ZeroInOneOut { result: LocalId::new(3) }),
            Operation::GasPrice(ZeroInOneOut { result: LocalId::new(4) }),
            Operation::CallDataSize(ZeroInOneOut { result: LocalId::new(5) }),
            Operation::CodeSize(ZeroInOneOut { result: LocalId::new(6) }),
            Operation::Gas(ZeroInOneOut { result: LocalId::new(7) }),
            Operation::ReturnDataSize(ZeroInOneOut { result: LocalId::new(8) }),
            Operation::SelfBalance(ZeroInOneOut { result: LocalId::new(9) }),
            // Block information
            Operation::Coinbase(ZeroInOneOut { result: LocalId::new(10) }),
            Operation::Timestamp(ZeroInOneOut { result: LocalId::new(11) }),
            Operation::Number(ZeroInOneOut { result: LocalId::new(12) }),
            Operation::Difficulty(ZeroInOneOut { result: LocalId::new(13) }),
            Operation::GasLimit(ZeroInOneOut { result: LocalId::new(14) }),
            Operation::ChainId(ZeroInOneOut { result: LocalId::new(15) }),
            Operation::BaseFee(ZeroInOneOut { result: LocalId::new(16) }),
            // Test operations that take input
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(17), value: 1 }),
            Operation::BlockHash(OneInOneOut {
                arg1: LocalId::new(17), // block number
                result: LocalId::new(18),
            }),
            // Balance of caller
            Operation::Balance(OneInOneOut {
                arg1: LocalId::new(0), // caller address
                result: LocalId::new(19),
            }),
            // ExtCodeSize of contract
            Operation::ExtCodeSize(OneInOneOut {
                arg1: LocalId::new(1), // contract address
                result: LocalId::new(20),
            }),
            // ExtCodeHash of contract
            Operation::ExtCodeHash(OneInOneOut {
                arg1: LocalId::new(1), // contract address
                result: LocalId::new(21),
            }),
            Operation::Stop,
        ]);

        let bytecode = ir_to_bytecode(program);
        println!("IR environmental bytecode ({} bytes): {:02x?}", bytecode.len(), bytecode);

        let result = execute_bytecode(bytecode, vec![]);

        match result {
            ExecutionResult::Success { gas_used, .. } => {
                println!("Environmental info execution succeeded, gas used: {}", gas_used);
            }
            _ => panic!("Environmental info execution failed: {:?}", result),
        }
    }

    #[test]
    fn test_bytecode_size_efficiency() {
        // Compare bytecode sizes for different operations
        let programs = vec![
            ("empty", create_simple_program(vec![Operation::Stop])),
            (
                "single_const",
                create_simple_program(vec![
                    Operation::LocalSetSmallConst(SetSmallConst {
                        local: LocalId::new(0),
                        value: 42,
                    }),
                    Operation::Stop,
                ]),
            ),
            (
                "arithmetic",
                create_simple_program(vec![
                    Operation::LocalSetSmallConst(SetSmallConst {
                        local: LocalId::new(0),
                        value: 10,
                    }),
                    Operation::LocalSetSmallConst(SetSmallConst {
                        local: LocalId::new(1),
                        value: 20,
                    }),
                    Operation::Add(TwoInOneOut {
                        arg1: LocalId::new(0),
                        arg2: LocalId::new(1),
                        result: LocalId::new(2),
                    }),
                    Operation::Stop,
                ]),
            ),
        ];

        println!("\nBytecode size comparison:");
        println!("-------------------------");
        for (name, program) in programs {
            let bytecode = ir_to_bytecode(program);
            println!("{:15} : {:3} bytes", name, bytecode.len());
        }
    }

    #[test]
    fn test_division_by_zero_returns_zero() {
        // Test that division by zero returns 0 (EVM behavior)
        let program = create_simple_program(vec![
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(0), value: 100 }),
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(1), value: 0 }),
            Operation::Div(TwoInOneOut {
                arg1: LocalId::new(0),
                arg2: LocalId::new(1),
                result: LocalId::new(2), // Result should be 0
            }),
            // Return the result: memory offset for local2 is 0x80 + 2*0x20 = 0xC0
            // IMPORTANT: The Return operation has swapped semantics!
            // - It loads arg1 then arg2, creating stack [arg1, arg2] with arg2 on top
            // - RETURN opcode uses top of stack as offset, second item as size
            // - Therefore: arg1 = size, arg2 = offset (counterintuitive!)
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(3), value: 0xC0 }), /* offset */
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(4), value: 32 }), /* size */
            Operation::Return(TwoInZeroOut {
                arg1: LocalId::new(4), // size (loaded first, becomes second stack item)
                arg2: LocalId::new(3), // offset (loaded second, becomes top of stack)
            }),
        ]);

        let bytecode = ir_to_bytecode(program);
        let result = execute_bytecode(bytecode, vec![]);
        validate_return_value(&result, U256::ZERO, "division by zero");
    }

    #[test]
    fn test_modulo_by_zero_returns_zero() {
        // Test that modulo by zero returns 0 (EVM behavior)
        let program = create_simple_program(vec![
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(0), value: 100 }),
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(1), value: 0 }),
            Operation::Mod(TwoInOneOut {
                arg1: LocalId::new(0),
                arg2: LocalId::new(1),
                result: LocalId::new(2), // Result should be 0
            }),
            // Return the result: memory offset for local2 is 0xC0
            // Using same swapped semantics as division test
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(3), value: 0xC0 }),
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(4), value: 32 }),
            Operation::Return(TwoInZeroOut {
                arg1: LocalId::new(4), // size
                arg2: LocalId::new(3), // offset
            }),
        ]);

        let bytecode = ir_to_bytecode(program);
        let result = execute_bytecode(bytecode, vec![]);
        validate_return_value(&result, U256::ZERO, "modulo by zero");
    }

    #[test]
    fn test_underflow_wraps_to_max() {
        // Test that 0 - 1 wraps to MAX_U256
        let program = create_simple_program(vec![
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(0), value: 0 }),
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(1), value: 1 }),
            // SUB semantics: loads arg1, then arg2, then computes arg1 - arg2
            // But EVM SUB pops b then a and computes a - b
            // So with our loading order, it computes arg2 - arg1!
            // To compute 0 - 1, we need arg2=0, arg1=1
            Operation::Sub(TwoInOneOut {
                arg1: LocalId::new(1),   // subtrahend (will be subtracted FROM arg2)
                arg2: LocalId::new(0),   // minuend (will have arg1 subtracted from it)
                result: LocalId::new(2), // Should wrap to MAX_U256
            }),
            // Return the result: memory offset for local2 is 0xC0
            // Using same swapped semantics as division test
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(3), value: 0xC0 }),
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(4), value: 32 }),
            Operation::Return(TwoInZeroOut {
                arg1: LocalId::new(4), // size
                arg2: LocalId::new(3), // offset
            }),
        ]);

        let bytecode = ir_to_bytecode(program);
        let result = execute_bytecode(bytecode, vec![]);
        validate_return_value(&result, U256::MAX, "underflow wrapping");
    }

    #[test]
    fn test_edge_cases() {
        // Test edge cases like division by zero and overflow scenarios
        let program = create_simple_program(vec![
            // Test division by zero (EVM returns 0)
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(0), value: 100 }),
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(1), value: 0 }),
            Operation::Div(TwoInOneOut {
                arg1: LocalId::new(0),   // 100
                arg2: LocalId::new(1),   // 0
                result: LocalId::new(2), // Should be 0
            }),
            // Test modulo by zero (EVM returns 0)
            Operation::Mod(TwoInOneOut {
                arg1: LocalId::new(0),   // 100
                arg2: LocalId::new(1),   // 0
                result: LocalId::new(3), // Should be 0
            }),
            // Test underflow: 0 - 1 wraps to MAX_U256
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(6), value: 0 }),
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(7), value: 1 }),
            Operation::Sub(TwoInOneOut {
                arg1: LocalId::new(6),   // 0
                arg2: LocalId::new(7),   // 1
                result: LocalId::new(8), // Should wrap to MAX_U256
            }),
            // Test shift beyond 256 bits (result should be 0)
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(9), value: 0xFF }),
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(10), value: 255 }),
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(11), value: 1 }),
            Operation::Add(TwoInOneOut {
                arg1: LocalId::new(10),
                arg2: LocalId::new(11),
                result: LocalId::new(12), // 256
            }),
            Operation::Shl(TwoInOneOut {
                arg1: LocalId::new(12),   // shift by 256 or more
                arg2: LocalId::new(9),    // value
                result: LocalId::new(13), // Should be 0
            }),
            Operation::Stop,
        ]);

        let bytecode = ir_to_bytecode(program);
        println!("Edge cases bytecode ({} bytes): {:02x?}", bytecode.len(), bytecode);

        let result = execute_bytecode(bytecode, vec![]);

        match result {
            ExecutionResult::Success { gas_used, .. } => {
                println!("Edge cases execution succeeded, gas used: {}", gas_used);
            }
            _ => panic!("Edge cases execution failed: {:?}", result),
        }
    }
}

#[cfg(test)]
mod integration_tests {
    use evm_glue::{assembler::assemble_minimized, assembly::Asm, opcodes::Opcode};
    use revm::primitives::{ExecutionResult, Output, U256};

    // Import helper functions from the tests module
    use super::tests::execute_bytecode;

    #[test]
    fn test_basic_assembly() {
        // Test that basic REVM execution works with hand-written bytecode
        // This is separate from IR tests to verify our test infrastructure
        let assembly = vec![
            Asm::Op(Opcode::PUSH1([42])), // Push 42
            Asm::Op(Opcode::PUSH1([0])),  // Push offset 0
            Asm::Op(Opcode::MSTORE),      // Store at memory[0]
            Asm::Op(Opcode::PUSH1([32])), // Push size 32
            Asm::Op(Opcode::PUSH1([0])),  // Push offset 0
            Asm::Op(Opcode::RETURN),      // Return memory[0:32]
        ];

        let (_marks, bytecode) = assemble_minimized(&assembly, true).unwrap();
        println!("Hand-written bytecode: {:02x?}", bytecode);

        let result = execute_bytecode(bytecode, vec![]);

        match result {
            ExecutionResult::Success { output, gas_used, .. } => {
                println!("Success! Gas used: {}", gas_used);
                let bytes = match output {
                    Output::Call(b) => b,
                    Output::Create(b, _) => b,
                };
                assert_eq!(bytes.len(), 32);
                assert_eq!(U256::from_be_slice(&bytes), U256::from(42));
            }
            _ => panic!("Execution failed: {:?}", result),
        }
    }
}
