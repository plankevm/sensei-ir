//! REVM integration tests for IR to EVM translation
//!
//! These tests verify that our generated bytecode executes correctly in REVM.

#[cfg(test)]
mod tests {
    use crate::{Translator, tests::helpers::create_simple_program, translator::memory::constants};
    use eth_ir_data::{LargeConstId, LocalId, LocalIndex, index_vec, operation::*};
    use evm_glue::assembler::assemble_minimized;
    use revm::{
        Evm, InMemoryDB,
        primitives::{ExecutionResult, TransactTo, U256, address},
    };

    // Test constants
    pub(super) const WORD_SIZE_BYTES: u64 = 32;
    const TEST_GAS_LIMIT: u64 = 1_000_000;
    const TEST_ETH_BALANCE: u64 = 1_000_000_000_000_000_000; // 1 ETH in wei

    /// Calculate memory offset for a local variable
    fn local_memory_offset(local_id: u32) -> u64 {
        constants::LOCALS_START as u64 + (local_id as u64) * constants::SLOT_SIZE as u64
    }

    /// Create Return operations for a local variable
    fn create_return_for_local(
        local_id: u32,
        offset_local: u32,
        size_local: u32,
    ) -> Vec<Operation> {
        vec![
            Operation::LocalSetSmallConst(SetSmallConst {
                local: LocalId::new(offset_local),
                value: local_memory_offset(local_id),
            }),
            Operation::LocalSetSmallConst(SetSmallConst {
                local: LocalId::new(size_local),
                value: WORD_SIZE_BYTES,
            }),
            Operation::Return(TwoInZeroOut {
                arg1: LocalId::new(offset_local),
                arg2: LocalId::new(size_local),
            }),
        ]
    }

    /// Helper to setup and execute bytecode in REVM
    pub(super) fn execute_bytecode(bytecode: Vec<u8>, calldata: Vec<u8>) -> ExecutionResult {
        let mut evm = create_evm_with_bytecode(bytecode, calldata);
        evm.transact_commit().expect("Transaction should succeed")
    }

    /// Create an EVM instance with deployed bytecode and calldata
    fn create_evm_with_bytecode(
        bytecode: Vec<u8>,
        calldata: Vec<u8>,
    ) -> Evm<'static, (), InMemoryDB> {
        let mut db = InMemoryDB::default();
        let contract_addr = address!("1000000000000000000000000000000000000000");
        let caller_addr = address!("9000000000000000000000000000000000000000");

        // Deploy contract
        db.insert_account_info(
            contract_addr,
            revm::primitives::AccountInfo {
                balance: U256::ZERO,
                nonce: 0,
                code_hash: revm::primitives::keccak256(&bytecode),
                code: Some(revm::primitives::Bytecode::new_raw(bytecode.into())),
            },
        );

        // Fund caller
        db.insert_account_info(
            caller_addr,
            revm::primitives::AccountInfo {
                balance: U256::from(TEST_ETH_BALANCE), // 1 ETH
                nonce: 0,
                code_hash: revm::primitives::KECCAK_EMPTY,
                code: None,
            },
        );

        // Create EVM instance with standard test configuration
        Evm::builder()
            .with_db(db)
            .modify_tx_env(|tx| {
                tx.caller = caller_addr;
                tx.transact_to = TransactTo::Call(contract_addr);
                tx.data = calldata.into();
                tx.gas_limit = TEST_GAS_LIMIT;
                tx.gas_price = U256::ZERO;
                tx.value = U256::ZERO;
            })
            .build()
    }

    /// Helper to translate IR program to bytecode
    pub(super) fn ir_to_bytecode(program: eth_ir_data::EthIRProgram) -> Vec<u8> {
        let mut translator = Translator::new(program);
        translator.translate().expect("Translation should succeed");
        let assembly = translator.into_asm();
        // Use minimized assembly for efficient bytecode
        let (_marks, bytecode) =
            assemble_minimized(&assembly, true).expect("Assembly should succeed");
        bytecode
    }

    /// Helper to validate execution results with Return operation
    fn validate_return_value(result: &ExecutionResult, expected: U256, description: &str) {
        match result {
            ExecutionResult::Success { output, .. } => {
                let bytes = match output {
                    revm::primitives::Output::Call(b) => b,
                    revm::primitives::Output::Create(b, _) => b,
                };
                assert_eq!(
                    bytes.len(),
                    WORD_SIZE_BYTES as usize,
                    "Expected {} bytes for {}, got {}",
                    WORD_SIZE_BYTES,
                    description,
                    bytes.len()
                );
                let actual = U256::from_be_slice(&bytes);
                assert_eq!(
                    actual, expected,
                    "Failed validation for {}: expected {}, got {}",
                    description, expected, actual
                );
            }
            result => assert!(
                matches!(result, ExecutionResult::Success { .. }),
                "Execution failed when validating {}: {:?}",
                description,
                result
            ),
        }
    }

    #[test]
    fn test_ir_simple_constant() {
        // Test that our IR translator can handle simple constants
        let program = create_simple_program(vec![
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(0), value: 100 }),
            Operation::Stop,
        ]);

        let bytecode = ir_to_bytecode(program);
        let result = execute_bytecode(bytecode, vec![]);

        assert!(
            matches!(result, ExecutionResult::Success { .. }),
            "IR execution failed: {:?}",
            result
        );
    }

    #[test]
    fn test_ir_arithmetic() {
        // Test arithmetic operations including signed operations
        let mut operations = vec![
            // Setup values for AddMod/MulMod in contiguous locals
            // local0 = 20 (first operand)
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(0), value: 20 }),
            // local1 = 22 (second operand)
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(1), value: 22 }),
            // local2 = 10 (modulus for AddMod)
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(2), value: 10 }),
            // local3 = (20 + 22) % 10 = 2 (AddMod)
            Operation::AddMod(LargeInOneOut::<3> {
                args_start: LocalIndex::new(0), // uses contiguous locals 0, 1, 2
                result: LocalId::new(3),
            }),
            // Setup for MulMod with contiguous locals
            // local4 = 20 (first operand)
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(4), value: 20 }),
            // local5 = 22 (second operand)
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(5), value: 22 }),
            // local6 = 100 (modulus)
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(6), value: 100 }),
            // local7 = (20 * 22) % 100 = 40 (MulMod)
            Operation::MulMod(LargeInOneOut::<3> {
                args_start: LocalIndex::new(4), // uses contiguous locals 4, 5, 6
                result: LocalId::new(7),
            }),
            // Basic arithmetic operations
            // local8 = local0 + local1 = 42
            Operation::Add(TwoInOneOut {
                arg1: LocalId::new(0),
                arg2: LocalId::new(1),
                result: LocalId::new(8),
            }),
            // local9 = local8 - local0 = 22
            Operation::Sub(TwoInOneOut {
                arg1: LocalId::new(8),
                arg2: LocalId::new(0),
                result: LocalId::new(9),
            }),
            // local10 = 2 (for division/modulo ops)
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(10), value: 2 }),
            // local11 = local0 * 2 = 40
            Operation::Mul(TwoInOneOut {
                arg1: LocalId::new(0),
                arg2: LocalId::new(10),
                result: LocalId::new(11),
            }),
            // local12 = local8 / 2 = 21
            Operation::Div(TwoInOneOut {
                arg1: LocalId::new(8),
                arg2: LocalId::new(10),
                result: LocalId::new(12),
            }),
            // local13 = local8 % 10 = 2
            Operation::Mod(TwoInOneOut {
                arg1: LocalId::new(8),
                arg2: LocalId::new(2), // reuse local2 which has value 10
                result: LocalId::new(13),
            }),
            // local14 = 3 (exponent)
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(14), value: 3 }),
            // local15 = 2^3 = 8
            Operation::Exp(TwoInOneOut {
                arg1: LocalId::new(10), // 2
                arg2: LocalId::new(14), // 3
                result: LocalId::new(15),
            }),
            // Test signed operations
            // Note: Using small constants for negative numbers - they will be sign-extended by EVM
            // local16 = 0xFB (will be treated as -5 in signed context)
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(16), value: 0xFB }),
            // local17 = 0xF6 (will be treated as -10 in signed context)
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(17), value: 0xF6 }),
            // local18 = -10 / -5 = 2 (SDiv)
            Operation::SDiv(TwoInOneOut {
                arg1: LocalId::new(17), // -10
                arg2: LocalId::new(16), // -5
                result: LocalId::new(18),
            }),
            // local19 = 0xFD (will be treated as -3 in signed context)
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(19), value: 0xFD }),
            // local20 = -10 % -3 = -1 (SMod)
            Operation::SMod(TwoInOneOut {
                arg1: LocalId::new(17), // -10
                arg2: LocalId::new(19), // -3
                result: LocalId::new(20),
            }),
            // Test SignExtend: sign extend byte 0xFB to full word
            // local21 = 0 (byte position)
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(21), value: 0 }),
            Operation::SignExtend(TwoInOneOut {
                arg1: LocalId::new(21), // byte position 0
                arg2: LocalId::new(16), // 0xFB
                result: LocalId::new(22),
            }),
        ];
        operations.extend(create_return_for_local(8, 23, 24));

        let program = create_simple_program(operations);
        let bytecode = ir_to_bytecode(program);
        let result = execute_bytecode(bytecode, vec![]);

        // Verify Add: 20 + 22 = 42
        validate_return_value(&result, U256::from(42), "Add (20+22)");
    }

    #[test]
    fn test_ir_storage() {
        // Test storage operations
        // NOTE: Storage operations in init code (deployment) don't persist
        // This test verifies that the opcodes are generated correctly
        let program = create_simple_program(vec![
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(0), value: 0 }),
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(1), value: 42 }),
            Operation::SStore(TwoInZeroOut {
                arg1: LocalId::new(0), // slot
                arg2: LocalId::new(1), // value
            }),
            Operation::SLoad(OneInOneOut {
                arg1: LocalId::new(0),   // slot
                result: LocalId::new(2), // will be 0 during init
            }),
            Operation::Stop,
        ]);

        let bytecode = ir_to_bytecode(program);
        let result = execute_bytecode(bytecode, vec![]);

        // Verify execution succeeds (opcodes are valid)
        assert!(
            matches!(result, ExecutionResult::Success { .. }),
            "Storage operations should execute without reverting"
        );

        if let ExecutionResult::Success { gas_used, .. } = result {
            // Storage operations should consume gas
            assert!(gas_used > 0, "Storage operations should consume gas");
        }
    }

    #[test]
    fn test_ir_comparison() {
        // Test comparison operations including signed comparisons
        let mut operations = vec![
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(0), value: 10 }),
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(1), value: 20 }),
            Operation::Lt(TwoInOneOut {
                arg1: LocalId::new(0),
                arg2: LocalId::new(1),
                result: LocalId::new(2),
            }),
            Operation::Gt(TwoInOneOut {
                arg1: LocalId::new(0),
                arg2: LocalId::new(1),
                result: LocalId::new(3),
            }),
            Operation::Eq(TwoInOneOut {
                arg1: LocalId::new(0),
                arg2: LocalId::new(1),
                result: LocalId::new(4),
            }),
            Operation::Eq(TwoInOneOut {
                arg1: LocalId::new(0),
                arg2: LocalId::new(0),
                result: LocalId::new(5),
            }),
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(6), value: 0 }),
            Operation::IsZero(OneInOneOut { arg1: LocalId::new(6), result: LocalId::new(7) }),
            Operation::IsZero(OneInOneOut { arg1: LocalId::new(0), result: LocalId::new(8) }),
            // Test signed comparisons with negative numbers
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(9), value: 0xFB }),
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(10), value: 0xF6 }),
            Operation::SLt(TwoInOneOut {
                arg1: LocalId::new(10), // -10
                arg2: LocalId::new(9),  // -5
                result: LocalId::new(11),
            }),
            Operation::SGt(TwoInOneOut {
                arg1: LocalId::new(9),  // -5
                arg2: LocalId::new(10), // -10
                result: LocalId::new(12),
            }),
            Operation::Lt(TwoInOneOut {
                arg1: LocalId::new(0), // 10
                arg2: LocalId::new(9), // 0xFB (251 unsigned)
                result: LocalId::new(13),
            }),
        ];
        operations.extend(create_return_for_local(2, 14, 15));

        let program = create_simple_program(operations);
        let bytecode = ir_to_bytecode(program);
        let result = execute_bytecode(bytecode, vec![]);

        // Verify Lt: 10 < 20 = true (1)
        validate_return_value(&result, U256::from(1), "Lt(10, 20)");
    }

    #[test]
    fn test_ir_bitwise() {
        // Test bitwise and shift operations
        let program = create_simple_program(vec![
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(0), value: 0xFF }),
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(1), value: 0x0F }),
            Operation::And(TwoInOneOut {
                arg1: LocalId::new(0),
                arg2: LocalId::new(1),
                result: LocalId::new(2),
            }),
            Operation::Or(TwoInOneOut {
                arg1: LocalId::new(0),
                arg2: LocalId::new(1),
                result: LocalId::new(3),
            }),
            Operation::Xor(TwoInOneOut {
                arg1: LocalId::new(0),
                arg2: LocalId::new(1),
                result: LocalId::new(4),
            }),
            Operation::Not(OneInOneOut { arg1: LocalId::new(1), result: LocalId::new(5) }),
            // Test Byte operation: extract byte at position 31 from 0xFF
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(6), value: 31 }),
            Operation::Byte(TwoInOneOut {
                arg1: LocalId::new(6), // byte position 31 (rightmost)
                arg2: LocalId::new(0), // value 0xFF
                result: LocalId::new(7),
            }),
            // Test shift operations
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(8), value: 4 }),
            Operation::Shl(TwoInOneOut {
                arg1: LocalId::new(8), // shift amount
                arg2: LocalId::new(1), // value 0x0F
                result: LocalId::new(9),
            }),
            Operation::Shr(TwoInOneOut {
                arg1: LocalId::new(8), // shift amount
                arg2: LocalId::new(0), // value 0xFF
                result: LocalId::new(10),
            }),
            // Test arithmetic shift with negative number
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(11), value: 0xF0 }),
            Operation::Sar(TwoInOneOut {
                arg1: LocalId::new(8),  // shift amount
                arg2: LocalId::new(11), // value -16
                result: LocalId::new(12),
            }),
            Operation::Stop,
        ]);

        let bytecode = ir_to_bytecode(program);
        let result = execute_bytecode(bytecode, vec![]);

        assert!(
            matches!(result, ExecutionResult::Success { .. }),
            "Bitwise execution failed: {:?}",
            result
        );
    }

    #[test]
    fn test_ir_memory_operations() {
        // Test memory copy operations
        let program = create_simple_program(vec![
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(0), value: 42 }),
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(1), value: 0 }),
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(2), value: 32 }),
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(3), value: 32 }),
            Operation::MCopy(ThreeInZeroOut {
                arg1: LocalId::new(2), // dest
                arg2: LocalId::new(1), // source
                arg3: LocalId::new(3), // length
            }),
            Operation::Stop,
        ]);

        let bytecode = ir_to_bytecode(program);
        let result = execute_bytecode(bytecode, vec![]);

        assert!(
            matches!(result, ExecutionResult::Success { .. }),
            "Memory ops execution failed: {:?}",
            result
        );
    }

    #[test]
    fn test_ir_environmental_info() {
        // Test environmental and block information operations
        let program = create_simple_program(vec![
            Operation::Caller(ZeroInOneOut { result: LocalId::new(0) }),
            Operation::Address(ZeroInOneOut { result: LocalId::new(1) }),
            Operation::CallValue(ZeroInOneOut { result: LocalId::new(2) }),
            Operation::Origin(ZeroInOneOut { result: LocalId::new(3) }),
            Operation::GasPrice(ZeroInOneOut { result: LocalId::new(4) }),
            Operation::CallDataSize(ZeroInOneOut { result: LocalId::new(5) }),
            Operation::CodeSize(ZeroInOneOut { result: LocalId::new(6) }),
            Operation::Gas(ZeroInOneOut { result: LocalId::new(7) }),
            Operation::ReturnDataSize(ZeroInOneOut { result: LocalId::new(8) }),
            Operation::SelfBalance(ZeroInOneOut { result: LocalId::new(9) }),
            Operation::Coinbase(ZeroInOneOut { result: LocalId::new(10) }),
            Operation::Timestamp(ZeroInOneOut { result: LocalId::new(11) }),
            Operation::Number(ZeroInOneOut { result: LocalId::new(12) }),
            Operation::Difficulty(ZeroInOneOut { result: LocalId::new(13) }),
            Operation::GasLimit(ZeroInOneOut { result: LocalId::new(14) }),
            Operation::ChainId(ZeroInOneOut { result: LocalId::new(15) }),
            Operation::BaseFee(ZeroInOneOut { result: LocalId::new(16) }),
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(17), value: 1 }),
            Operation::BlockHash(OneInOneOut {
                arg1: LocalId::new(17), // block number
                result: LocalId::new(18),
            }),
            Operation::Balance(OneInOneOut {
                arg1: LocalId::new(0), // caller address
                result: LocalId::new(19),
            }),
            Operation::ExtCodeSize(OneInOneOut {
                arg1: LocalId::new(1), // contract address
                result: LocalId::new(20),
            }),
            Operation::ExtCodeHash(OneInOneOut {
                arg1: LocalId::new(1), // contract address
                result: LocalId::new(21),
            }),
            Operation::Stop,
        ]);

        let bytecode = ir_to_bytecode(program);
        let result = execute_bytecode(bytecode, vec![]);

        assert!(
            matches!(result, ExecutionResult::Success { .. }),
            "Environmental info execution failed: {:?}",
            result
        );
    }

    #[test]
    fn test_bytecode_size_efficiency() {
        // Compare bytecode sizes for different operations
        let programs = vec![
            ("empty", create_simple_program(vec![Operation::Stop])),
            (
                "single_const",
                create_simple_program(vec![
                    Operation::LocalSetSmallConst(SetSmallConst {
                        local: LocalId::new(0),
                        value: 42,
                    }),
                    Operation::Stop,
                ]),
            ),
            (
                "arithmetic",
                create_simple_program(vec![
                    Operation::LocalSetSmallConst(SetSmallConst {
                        local: LocalId::new(0),
                        value: 10,
                    }),
                    Operation::LocalSetSmallConst(SetSmallConst {
                        local: LocalId::new(1),
                        value: 20,
                    }),
                    Operation::Add(TwoInOneOut {
                        arg1: LocalId::new(0),
                        arg2: LocalId::new(1),
                        result: LocalId::new(2),
                    }),
                    Operation::Stop,
                ]),
            ),
        ];

        for (name, program) in programs {
            let bytecode = ir_to_bytecode(program);
            // Verify bytecode was generated
            assert!(!bytecode.is_empty(), "Bytecode for {} should not be empty", name);
        }
    }

    #[test]
    fn test_division_by_zero_returns_zero() {
        // Test that division by zero returns 0 (EVM behavior)
        let mut operations = vec![
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(0), value: 100 }),
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(1), value: 0 }),
            Operation::Div(TwoInOneOut {
                arg1: LocalId::new(0),
                arg2: LocalId::new(1),
                result: LocalId::new(2),
            }),
        ];
        operations.extend(create_return_for_local(2, 3, 4));

        let program = create_simple_program(operations);
        let bytecode = ir_to_bytecode(program);
        let result = execute_bytecode(bytecode, vec![]);
        validate_return_value(&result, U256::ZERO, "division by zero");
    }

    #[test]
    fn test_modulo_by_zero_returns_zero() {
        // Test that modulo by zero returns 0 (EVM behavior)
        let mut operations = vec![
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(0), value: 100 }),
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(1), value: 0 }),
            Operation::Mod(TwoInOneOut {
                arg1: LocalId::new(0),
                arg2: LocalId::new(1),
                result: LocalId::new(2),
            }),
        ];
        operations.extend(create_return_for_local(2, 3, 4));

        let program = create_simple_program(operations);
        let bytecode = ir_to_bytecode(program);
        let result = execute_bytecode(bytecode, vec![]);
        validate_return_value(&result, U256::ZERO, "modulo by zero");
    }

    #[test]
    fn test_underflow_wraps_to_max() {
        // Test that 0 - 1 wraps to MAX_U256
        let mut operations = vec![
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(0), value: 0 }),
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(1), value: 1 }),
            Operation::Sub(TwoInOneOut {
                arg1: LocalId::new(0),
                arg2: LocalId::new(1),
                result: LocalId::new(2),
            }),
        ];
        operations.extend(create_return_for_local(2, 3, 4));

        let program = create_simple_program(operations);
        let bytecode = ir_to_bytecode(program);
        let result = execute_bytecode(bytecode, vec![]);
        validate_return_value(&result, U256::MAX, "underflow wrapping");
    }

    #[test]
    fn test_keccak256_operation() {
        // Test Keccak256 hashing - hash empty input first
        let mut operations = vec![
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(0), value: 0 }),
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(1), value: 0 }),
            Operation::Keccak256(TwoInOneOut {
                arg1: LocalId::new(0),   // offset
                arg2: LocalId::new(1),   // length
                result: LocalId::new(2), // hash result
            }),
        ];
        operations.extend(create_return_for_local(2, 3, 4));

        let program = create_simple_program(operations);
        let bytecode = ir_to_bytecode(program);
        let result = execute_bytecode(bytecode, vec![]);

        // Expected hash of empty input is the well-known value:
        // 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470
        let expected_hash = U256::from_be_bytes([
            0xc5, 0xd2, 0x46, 0x01, 0x86, 0xf7, 0x23, 0x3c, 0x92, 0x7e, 0x7d, 0xb2, 0xdc, 0xc7,
            0x03, 0xc0, 0xe5, 0x00, 0xb6, 0x53, 0xca, 0x82, 0x27, 0x3b, 0x7b, 0xfa, 0xd8, 0x04,
            0x5d, 0x85, 0xa4, 0x70,
        ]);

        validate_return_value(&result, expected_hash, "Keccak256 of empty input");
    }

    #[test]
    fn test_calldata_operations() {
        // Test CallDataLoad and CallDataCopy
        let mut operations = vec![
            Operation::CallDataSize(ZeroInOneOut { result: LocalId::new(0) }),
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(1), value: 0 }),
            Operation::CallDataLoad(OneInOneOut { arg1: LocalId::new(1), result: LocalId::new(2) }),
        ];
        operations.extend(create_return_for_local(2, 3, 4));

        let program = create_simple_program(operations);
        // Test calldata: 0x1234567890abcdef (8 bytes)
        let calldata = vec![0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef];
        let bytecode = ir_to_bytecode(program);
        let result = execute_bytecode(bytecode, calldata);

        // CallDataLoad should load 32 bytes starting at offset 0
        // Since we only have 8 bytes, it pads with zeros on the right
        // Expected: 0x1234567890abcdef0000000000000000000000000000000000000000000000
        let expected = U256::from_be_bytes([
            0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
        ]);

        validate_return_value(&result, expected, "CallDataLoad");
    }

    #[test]
    fn test_log_operations() {
        // Test Log0 succeeds
        let program = create_simple_program(vec![
            Operation::LocalSetSmallConst(SetSmallConst {
                local: LocalId::new(0),
                value: 0x12345678,
            }),
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(1), value: 0 }),
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(2), value: 1 }),
            Operation::Log0(TwoInZeroOut {
                arg1: LocalId::new(1), // offset
                arg2: LocalId::new(2), // size
            }),
            Operation::Stop,
        ]);

        let bytecode = ir_to_bytecode(program);
        let result = execute_bytecode(bytecode, vec![]);

        assert!(
            matches!(result, ExecutionResult::Success { .. }),
            "Log0 operation failed: {:?}",
            result
        );

        // Now test Log1 separately
        let program2 = create_simple_program(vec![
            Operation::LocalSetSmallConst(SetSmallConst {
                local: LocalId::new(0),
                value: 0x12345678,
            }),
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(1), value: 0 }),
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(2), value: 1 }),
            Operation::LocalSetSmallConst(SetSmallConst {
                local: LocalId::new(3),
                value: 0xAABBCCDD,
            }),
            Operation::Log1(ThreeInZeroOut {
                arg1: LocalId::new(1), // offset
                arg2: LocalId::new(2), // size
                arg3: LocalId::new(3), // topic
            }),
            Operation::Stop,
        ]);

        let bytecode2 = ir_to_bytecode(program2);
        let result2 = execute_bytecode(bytecode2, vec![]);

        assert!(
            matches!(result2, ExecutionResult::Success { .. }),
            "Log1 operation failed: {:?}",
            result2
        );
    }

    #[test]
    fn test_transient_storage() {
        // Test TStore and TLoad
        // NOTE: Transient storage in init code may not persist as expected
        // This test verifies that the opcodes are generated correctly
        let program = create_simple_program(vec![
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(0), value: 42 }),
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(1), value: 999 }),
            Operation::TStore(TwoInZeroOut { arg1: LocalId::new(0), arg2: LocalId::new(1) }),
            Operation::TLoad(OneInOneOut { arg1: LocalId::new(0), result: LocalId::new(2) }),
            Operation::Stop,
        ]);

        let bytecode = ir_to_bytecode(program);
        let result = execute_bytecode(bytecode, vec![]);

        // Verify execution succeeds (opcodes are valid)
        assert!(
            matches!(result, ExecutionResult::Success { .. }),
            "Transient storage operations should execute without reverting"
        );
    }

    #[test]
    fn test_edge_cases() {
        // Test edge cases like division by zero and overflow scenarios
        let program = create_simple_program(vec![
            // Test division by zero (EVM returns 0)
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(0), value: 100 }),
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(1), value: 0 }),
            Operation::Div(TwoInOneOut {
                arg1: LocalId::new(0),
                arg2: LocalId::new(1),
                result: LocalId::new(2),
            }),
            // Test modulo by zero (EVM returns 0)
            Operation::Mod(TwoInOneOut {
                arg1: LocalId::new(0),
                arg2: LocalId::new(1),
                result: LocalId::new(3),
            }),
            // Test underflow: 0 - 1 wraps to MAX_U256
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(6), value: 0 }),
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(7), value: 1 }),
            Operation::Sub(TwoInOneOut {
                arg1: LocalId::new(6),
                arg2: LocalId::new(7),
                result: LocalId::new(8),
            }),
            // Test shift beyond 256 bits (result should be 0)
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(9), value: 0xFF }),
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(10), value: 255 }),
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(11), value: 1 }),
            Operation::Add(TwoInOneOut {
                arg1: LocalId::new(10),
                arg2: LocalId::new(11),
                result: LocalId::new(12),
            }),
            Operation::Shl(TwoInOneOut {
                arg1: LocalId::new(12),
                arg2: LocalId::new(9),
                result: LocalId::new(13),
            }),
            Operation::Stop,
        ]);

        let bytecode = ir_to_bytecode(program);
        let result = execute_bytecode(bytecode, vec![]);

        assert!(
            matches!(result, ExecutionResult::Success { .. }),
            "Edge cases execution failed: {:?}",
            result
        );
    }

    #[test]
    fn test_raw_storage() {
        // Test storage with raw assembly to verify REVM setup works
        use evm_glue::{assembler::assemble_minimized, assembly::Asm, opcodes::Opcode};

        let assembly = vec![
            Asm::Op(Opcode::PUSH1([42])),
            Asm::Op(Opcode::PUSH1([0])),
            Asm::Op(Opcode::SSTORE),
            Asm::Op(Opcode::PUSH1([0])),
            Asm::Op(Opcode::SLOAD),
            Asm::Op(Opcode::PUSH1([0])),
            Asm::Op(Opcode::MSTORE),
            Asm::Op(Opcode::PUSH1([32])),
            Asm::Op(Opcode::PUSH1([0])),
            Asm::Op(Opcode::RETURN),
        ];

        let (_marks, bytecode) = assemble_minimized(&assembly, true).unwrap();
        let result = execute_bytecode(bytecode, vec![]);

        validate_return_value(&result, U256::from(42), "Raw SSTORE/SLOAD");
    }

    // ============ Failure scenario tests ============

    #[test]
    fn test_revert_operation() {
        // Test that Revert properly reverts execution
        let program = create_simple_program(vec![
            Operation::LocalSetSmallConst(SetSmallConst {
                local: LocalId::new(0),
                value: 0xDEADBEEF,
            }),
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(1), value: 0 }), /* offset */
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(2), value: 4 }), /* size (4 bytes) */
            // Revert with the data
            Operation::Revert(TwoInZeroOut {
                arg1: LocalId::new(1), // offset
                arg2: LocalId::new(2), // size
            }),
        ]);

        let bytecode = ir_to_bytecode(program);
        let result = execute_bytecode(bytecode, vec![]);

        // Verify execution reverts
        assert!(
            matches!(result, ExecutionResult::Revert { .. }),
            "Expected revert but got: {:?}",
            result
        );
    }

    #[test]
    fn test_invalid_opcode() {
        // Test that Invalid operation causes execution to fail
        let program = create_simple_program(vec![
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(0), value: 42 }),
            Operation::Invalid,
        ]);

        let bytecode = ir_to_bytecode(program);
        let result = execute_bytecode(bytecode, vec![]);

        assert!(
            matches!(result, ExecutionResult::Halt { .. }),
            "Expected halt on invalid opcode but got: {:?}",
            result
        );
    }

    #[test]
    fn test_out_of_gas() {
        // Test that operations fail when out of gas
        // Use multiple expensive operations to consume gas
        let mut operations = vec![];

        // Create many SSTORE operations which are expensive (20000 gas each)
        for i in 0..10 {
            operations.push(Operation::LocalSetSmallConst(SetSmallConst {
                local: LocalId::new(i * 2),
                value: i as u64,
            }));
            operations.push(Operation::LocalSetSmallConst(SetSmallConst {
                local: LocalId::new(i * 2 + 1),
                value: (i + 100) as u64,
            }));
            operations.push(Operation::SStore(TwoInZeroOut {
                arg1: LocalId::new(i * 2),
                arg2: LocalId::new(i * 2 + 1),
            }));
        }
        operations.push(Operation::Stop);

        let program = create_simple_program(operations);

        let bytecode = ir_to_bytecode(program);

        // Create EVM with limited gas for this specific test
        let mut evm = create_evm_with_bytecode(bytecode, vec![]);

        // Override gas limit to force out-of-gas
        evm.context.evm.inner.env.tx.gas_limit = 30000;

        let result = evm.transact_commit().unwrap();

        assert!(
            matches!(result, ExecutionResult::Halt { .. }),
            "Expected out of gas halt but got: {:?}",
            result
        );
    }

    // ============ Tests for missing operations ============

    #[test]
    fn test_environmental_opcodes() {
        // Test environmental opcodes like Caller, Origin, CallValue, etc.
        let program = create_simple_program(vec![
            Operation::Caller(ZeroInOneOut { result: LocalId::new(0) }),
            Operation::Origin(ZeroInOneOut { result: LocalId::new(1) }),
            Operation::CallValue(ZeroInOneOut { result: LocalId::new(2) }),
            Operation::Address(ZeroInOneOut { result: LocalId::new(3) }),
            Operation::GasPrice(ZeroInOneOut { result: LocalId::new(4) }),
            Operation::CallDataSize(ZeroInOneOut { result: LocalId::new(5) }),
            Operation::CodeSize(ZeroInOneOut { result: LocalId::new(6) }),
            Operation::ReturnDataSize(ZeroInOneOut { result: LocalId::new(7) }),
            Operation::Gas(ZeroInOneOut { result: LocalId::new(8) }),
            Operation::Stop,
        ]);

        let bytecode = ir_to_bytecode(program);
        let result = execute_bytecode(bytecode, vec![]);

        // Verify all environmental opcodes execute successfully
        assert!(
            matches!(result, ExecutionResult::Success { .. }),
            "Environmental opcodes failed: {:?}",
            result
        );
    }

    #[test]
    fn test_block_info_opcodes() {
        // Test block information opcodes
        let program = create_simple_program(vec![
            Operation::Coinbase(ZeroInOneOut { result: LocalId::new(0) }),
            Operation::Timestamp(ZeroInOneOut { result: LocalId::new(1) }),
            Operation::Number(ZeroInOneOut { result: LocalId::new(2) }),
            Operation::Difficulty(ZeroInOneOut { result: LocalId::new(3) }),
            Operation::GasLimit(ZeroInOneOut { result: LocalId::new(4) }),
            Operation::ChainId(ZeroInOneOut { result: LocalId::new(5) }),
            Operation::BaseFee(ZeroInOneOut { result: LocalId::new(6) }),
            Operation::BlobBaseFee(ZeroInOneOut { result: LocalId::new(7) }),
            Operation::Stop,
        ]);

        let bytecode = ir_to_bytecode(program);
        let result = execute_bytecode(bytecode, vec![]);

        // Verify all block info opcodes execute successfully
        assert!(
            matches!(result, ExecutionResult::Success { .. }),
            "Block info opcodes failed: {:?}",
            result
        );
    }

    #[test]
    fn test_comparison_operations() {
        // Test comparison operations (Lt, Gt, SLt, SGt, Eq)
        let mut operations = vec![
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(0), value: 10 }),
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(1), value: 20 }),
            // Lt: 10 < 20 = 1
            Operation::Lt(TwoInOneOut {
                arg1: LocalId::new(0),
                arg2: LocalId::new(1),
                result: LocalId::new(2),
            }),
            // Gt: 10 > 20 = 0
            Operation::Gt(TwoInOneOut {
                arg1: LocalId::new(0),
                arg2: LocalId::new(1),
                result: LocalId::new(3),
            }),
            // Eq: 10 == 20 = 0
            Operation::Eq(TwoInOneOut {
                arg1: LocalId::new(0),
                arg2: LocalId::new(1),
                result: LocalId::new(4),
            }),
            // IsZero: 10 == 0 = 0
            Operation::IsZero(OneInOneOut { arg1: LocalId::new(0), result: LocalId::new(5) }),
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(6), value: 0 }),
            Operation::IsZero(OneInOneOut { arg1: LocalId::new(6), result: LocalId::new(7) }),
        ];

        operations.extend(create_return_for_local(2, 8, 9));

        let program = create_simple_program(operations);
        let bytecode = ir_to_bytecode(program);
        let result = execute_bytecode(bytecode, vec![]);

        // Lt(10, 20) should return 1 (true)
        validate_return_value(&result, U256::from(1), "Lt comparison");
    }

    #[test]
    fn test_bitwise_operations() {
        // Test bitwise operations (And, Or, Xor, Not, Byte, Shl, Shr, Sar)
        let mut operations = vec![
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(0), value: 0xFF }),
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(1), value: 0xF0 }),
            // And: 0xFF & 0xF0 = 0xF0
            Operation::And(TwoInOneOut {
                arg1: LocalId::new(0),
                arg2: LocalId::new(1),
                result: LocalId::new(2),
            }),
            // Or: 0xFF | 0xF0 = 0xFF
            Operation::Or(TwoInOneOut {
                arg1: LocalId::new(0),
                arg2: LocalId::new(1),
                result: LocalId::new(3),
            }),
            // Xor: 0xFF ^ 0xF0 = 0x0F
            Operation::Xor(TwoInOneOut {
                arg1: LocalId::new(0),
                arg2: LocalId::new(1),
                result: LocalId::new(4),
            }),
            // Not: ~0xFF = 0xFFFF...FF00
            Operation::Not(OneInOneOut { arg1: LocalId::new(0), result: LocalId::new(5) }),
            // Shl: 0xFF << 4 = 0xFF0
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(6), value: 4 }),
            Operation::Shl(TwoInOneOut {
                arg1: LocalId::new(6), // shift amount
                arg2: LocalId::new(0), // value
                result: LocalId::new(7),
            }),
            // Shr: 0xFF >> 4 = 0x0F
            Operation::Shr(TwoInOneOut {
                arg1: LocalId::new(6), // shift amount
                arg2: LocalId::new(0), // value
                result: LocalId::new(8),
            }),
        ];

        operations.extend(create_return_for_local(4, 9, 10));

        let program = create_simple_program(operations);
        let bytecode = ir_to_bytecode(program);
        let result = execute_bytecode(bytecode, vec![]);

        // Xor(0xFF, 0xF0) should return 0x0F
        validate_return_value(&result, U256::from(0x0F), "Xor operation");
    }

    #[test]
    fn test_memory_copy_operations() {
        // Test memory copy operations (MCopy, CallDataCopy, CodeCopy, ReturnDataCopy)
        let program = create_simple_program(vec![
            Operation::LocalSetSmallConst(SetSmallConst {
                local: LocalId::new(0),
                value: 0x12345678,
            }),
            // MCopy: copy 32 bytes from memory[0x80] to memory[0x100]
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(1), value: 0x100 }), /* dest */
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(2), value: 0x80 }), /* src */
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(3), value: 32 }), /* size */
            Operation::MCopy(ThreeInZeroOut {
                arg1: LocalId::new(1), // dest
                arg2: LocalId::new(2), // src
                arg3: LocalId::new(3), // size
            }),
            // CallDataCopy: copy 8 bytes of calldata to memory[0x200]
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(4), value: 0x200 }), /* dest */
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(5), value: 0 }), /* offset */
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(6), value: 8 }), /* size */
            Operation::CallDataCopy(ThreeInZeroOut {
                arg1: LocalId::new(4), // dest
                arg2: LocalId::new(5), // offset
                arg3: LocalId::new(6), // size
            }),
            // CodeCopy: copy 8 bytes of code to memory[0x300]
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(7), value: 0x300 }), /* dest */
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(8), value: 0 }), /* offset */
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(9), value: 8 }), /* size */
            Operation::CodeCopy(ThreeInZeroOut {
                arg1: LocalId::new(7), // dest
                arg2: LocalId::new(8), // offset
                arg3: LocalId::new(9), // size
            }),
            Operation::Stop,
        ]);

        let bytecode = ir_to_bytecode(program);
        let calldata = vec![0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF, 0x11, 0x22];
        let result = execute_bytecode(bytecode, calldata);

        // Verify all copy operations execute successfully
        assert!(
            matches!(result, ExecutionResult::Success { .. }),
            "Memory copy operations failed: {:?}",
            result
        );
    }

    #[test]
    fn test_self_destruct() {
        // Test SelfDestruct operation
        let program = create_simple_program(vec![
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(0), value: 0xBEEF }),
            Operation::SelfDestruct(OneInZeroOut { arg1: LocalId::new(0) }),
        ]);

        let bytecode = ir_to_bytecode(program);
        let result = execute_bytecode(bytecode, vec![]);

        // SelfDestruct should succeed with SelfDestruct reason
        assert!(
            matches!(
                result,
                ExecutionResult::Success {
                    reason: revm::primitives::SuccessReason::SelfDestruct,
                    ..
                }
            ),
            "Expected success with SelfDestruct reason but got: {:?}",
            result
        );
    }

    #[test]
    fn test_log_operations_extended() {
        // Test Log2, Log3, Log4 operations
        let program = create_simple_program(vec![
            Operation::LocalSetSmallConst(SetSmallConst {
                local: LocalId::new(0),
                value: 0x12345678,
            }),
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(1), value: 0 }), /* offset */
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(2), value: 4 }), /* size */
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(3), value: 0xAAA }), /* topic1 */
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(4), value: 0xBBB }), /* topic2 */
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(5), value: 0xCCC }), /* topic3 */
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(6), value: 0xDDD }), /* topic4 */
            // Log2
            Operation::Log2(LargeInZeroOut { args_start: LocalIndex::new(1) }),
            // Log3
            Operation::Log3(LargeInZeroOut { args_start: LocalIndex::new(1) }),
            // Log4
            Operation::Log4(LargeInZeroOut { args_start: LocalIndex::new(1) }),
            Operation::Stop,
        ]);

        let bytecode = ir_to_bytecode(program);
        let result = execute_bytecode(bytecode, vec![]);

        // Verify all log operations execute successfully
        assert!(
            matches!(result, ExecutionResult::Success { .. }),
            "Extended log operations failed: {:?}",
            result
        );
    }

    #[test]
    fn test_sign_extend_operation() {
        // Test SignExtend operation
        let mut operations = vec![
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(0), value: 0 }), /* byte position (0 = lowest byte) */
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(1), value: 0x80 }), /* value to sign extend */
            Operation::SignExtend(TwoInOneOut {
                arg1: LocalId::new(0),
                arg2: LocalId::new(1),
                result: LocalId::new(2),
            }),
        ];

        operations.extend(create_return_for_local(2, 3, 4));

        let program = create_simple_program(operations);
        let bytecode = ir_to_bytecode(program);
        let result = execute_bytecode(bytecode, vec![]);

        // Sign extending 0x80 from byte 0 should give 0xFFFF...FF80
        let expected = U256::from_be_bytes([
            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
            0xFF, 0xFF, 0xFF, 0x80,
        ]);
        validate_return_value(&result, expected, "SignExtend operation");
    }

    #[test]
    fn test_byte_operation() {
        // Test Byte operation - extracts a single byte from a word
        let mut operations = vec![
            Operation::LocalSetLargeConst(SetLargeConst {
                local: LocalId::new(0),
                cid: LargeConstId::new(0),
            }),
            Operation::LocalSetSmallConst(SetSmallConst { local: LocalId::new(1), value: 31 }),
            Operation::Byte(TwoInOneOut {
                arg1: LocalId::new(1), // position
                arg2: LocalId::new(0), // value
                result: LocalId::new(2),
            }),
        ];

        operations.extend(create_return_for_local(2, 3, 4));

        let mut program = create_simple_program(operations);
        // Set up a value with distinct bytes: 0x0102030405...1F20
        let mut bytes = [0u8; 32];
        for i in 0..32 {
            bytes[i] = (i + 1) as u8;
        }
        program.large_consts = index_vec![U256::from_be_bytes(bytes)];

        let bytecode = ir_to_bytecode(program);
        let result = execute_bytecode(bytecode, vec![]);

        // Byte at position 31 should be 0x20 (32nd byte)
        validate_return_value(&result, U256::from(0x20), "Byte extraction");
    }
}

#[cfg(test)]
mod integration_tests {
    use evm_glue::{assembler::assemble_minimized, assembly::Asm, opcodes::Opcode};
    use revm::primitives::{ExecutionResult, Output, U256};

    use super::tests::{WORD_SIZE_BYTES, execute_bytecode};

    #[test]
    fn test_basic_assembly() {
        // Test that basic REVM execution works with hand-written bytecode
        // This is separate from IR tests to verify our test infrastructure
        let assembly = vec![
            Asm::Op(Opcode::PUSH1([42])),
            Asm::Op(Opcode::PUSH1([0])),
            Asm::Op(Opcode::MSTORE),
            Asm::Op(Opcode::PUSH1([32])),
            Asm::Op(Opcode::PUSH1([0])),
            Asm::Op(Opcode::RETURN),
        ];

        let (_marks, bytecode) = assemble_minimized(&assembly, true).unwrap();
        let result = execute_bytecode(bytecode, vec![]);

        assert!(
            matches!(result, ExecutionResult::Success { .. }),
            "Execution failed: {:?}",
            result
        );
        if let ExecutionResult::Success { output, .. } = result {
            let bytes = match output {
                Output::Call(b) => b,
                Output::Create(b, _) => b,
            };
            assert_eq!(bytes.len(), WORD_SIZE_BYTES as usize);
            assert_eq!(U256::from_be_slice(&bytes), U256::from(42));
        }
    }
}
