//! Code generation from eth-ir to EVM bytecode
//!
//! This crate translates eth-ir programs to EVM assembly using evm-glue.
//!
//! Design approach:
//! - Memory-backed locals for simplicity (future: stack window optimization)
//! - Each LocalId gets a fixed memory slot
//! - Memory layout: 0x00-0x40 scratch, 0x40-0x60 free ptr, 0x60-0x80 return addr, 0x80+ locals

mod gas;
mod marks;
mod memory;

/// Runtime error codes for eth-ir generated bytecode
///
/// These are encoded as a single byte in the revert data to signal
/// specific error conditions at runtime. Using a single byte keeps
/// gas costs minimal while providing clear diagnostic information.
///
/// Error codes 0x00-0x7F are reserved for eth-ir runtime errors.
/// Error codes 0x80-0xFF are available for user-defined errors.
pub mod runtime_errors {
    /// Undefined behavior was encountered - the program is in an invalid state
    pub const UNDEFINED_BEHAVIOR: u8 = 0x00;

    /// Non-exhaustive switch without fallback - no case matched
    pub const SWITCH_NO_MATCH: u8 = 0x01;

    /// Invalid internal call - function doesn't exist
    pub const INVALID_INTERNAL_CALL: u8 = 0x02;

    /// Stack depth exceeded in internal calls
    pub const CALL_STACK_OVERFLOW: u8 = 0x03;

    /// Division by zero (if not handled by EVM)
    pub const DIVISION_BY_ZERO: u8 = 0x04;

    /// Array index out of bounds
    pub const INDEX_OUT_OF_BOUNDS: u8 = 0x05;

    /// Memory allocation failed
    pub const MEMORY_ALLOCATION_FAILED: u8 = 0x06;
}

#[cfg(test)]
mod property_tests;
#[cfg(test)]
mod revm_tests;
#[cfg(test)]
mod test_helpers;
#[cfg(test)]
mod test_operations;

pub use gas::{AdvancedGasEstimator, AdvancedGasReport, GasReport, SimpleGasEstimator};

use alloy_primitives::U256;
#[cfg(test)]
use eth_ir_data::FunctionId;
use eth_ir_data::{
    BasicBlockId, CasesId, Control, DataId, EthIRProgram, Idx, LargeConstId, LocalId,
    operation::HasArgs,
};
use evm_glue::assembly::{Asm, MarkRef, RefType};
use marks::{MarkAllocator, MarkId};
use memory::MemoryLayout;
use smallvec::SmallVec;
use std::{collections::HashSet, fmt, ops::Range};

/// Error type for code generation
#[derive(Debug)]
pub enum CodegenError {
    /// Local variable not found in memory layout
    LocalNotFound { local: LocalId },
    /// Data segment not found
    DataSegmentNotFound { segment: DataId },
    /// Invalid block reference
    InvalidBlockReference { block: BasicBlockId },
    /// Invalid cases reference
    InvalidCasesReference { cases: CasesId },
    /// Invalid local range
    InvalidLocalRange { range: Range<usize>, locals_len: usize },
    /// Invalid large constant reference
    InvalidLargeConstReference { constant: LargeConstId },
}

impl fmt::Display for CodegenError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            CodegenError::LocalNotFound { local } => {
                write!(f, "Local variable {:?} not found in memory layout", local)
            }
            CodegenError::DataSegmentNotFound { segment } => {
                write!(f, "Data segment {:?} not found", segment)
            }
            CodegenError::InvalidBlockReference { block } => {
                write!(f, "Invalid block reference {:?}", block)
            }
            CodegenError::InvalidCasesReference { cases } => {
                write!(f, "Invalid cases reference {:?}", cases)
            }
            CodegenError::InvalidLocalRange { range, locals_len } => {
                write!(
                    f,
                    "Invalid local range: tried to access locals[{}..{}] but locals.len() is {}",
                    range.start, range.end, locals_len
                )
            }
            CodegenError::InvalidLargeConstReference { constant } => {
                write!(f, "Invalid large constant reference {:?}", constant)
            }
        }
    }
}

impl std::error::Error for CodegenError {}

/// Result type alias for codegen operations
pub type Result<T> = std::result::Result<T, CodegenError>;

/// Main translator from IR to EVM assembly
pub struct Translator {
    /// The IR program being translated
    program: EthIRProgram,

    /// Memory layout for locals
    memory: MemoryLayout,

    /// Mark allocator for jump labels
    marks: MarkAllocator,

    /// Tracks which blocks have been translated
    translated_blocks: HashSet<BasicBlockId>,

    /// Generated assembly instructions
    asm: Vec<Asm>,

    /// Section marks for bytecode layout
    init_end_mark: MarkId,
    runtime_start_mark: MarkId,
    runtime_end_mark: MarkId,
    data_end_mark: MarkId,

    /// Marks for data segments
    data_marks: std::collections::HashMap<DataId, MarkId>,

    /// Track if we're currently translating init code
    is_translating_init: bool,

    /// Track if we've emitted a RETURN during init code generation
    init_has_return: bool,
}

impl Translator {
    /// Create a new translator for the given IR program
    pub fn new(program: EthIRProgram) -> Self {
        let mut marks = MarkAllocator::new();

        // Pre-allocate section marks
        let init_end_mark = marks.allocate_mark();
        let runtime_start_mark = init_end_mark; // Runtime immediately follows init
        let runtime_end_mark = marks.allocate_mark();
        let data_end_mark = marks.allocate_mark();

        // Estimate initial capacity for assembly based on program size
        // Most operations translate to 2-5 assembly instructions on average
        // Add extra capacity for initialization, deployment, and control flow
        let estimated_asm_size = program.operations.len() * 4 + 100;
        let blocks_count = program.basic_blocks.len();
        let data_segments_count = program.data_segments_start.len();

        Self {
            program,
            memory: MemoryLayout::new(),
            marks,
            // Pre-allocate based on basic blocks count since we track which blocks are translated
            translated_blocks: HashSet::with_capacity(blocks_count),
            asm: Vec::with_capacity(estimated_asm_size),
            init_end_mark,
            runtime_start_mark,
            runtime_end_mark,
            data_end_mark,
            // Pre-allocate based on data segments count
            data_marks: std::collections::HashMap::with_capacity(data_segments_count),
            is_translating_init: false,
            init_has_return: false,
        }
    }

    /// Translate the IR program to EVM assembly
    pub fn translate(&mut self) -> Result<()> {
        // Pre-allocate memory for all locals
        self.allocate_all_locals();

        // Pre-allocate marks for data segments
        for (segment_id, _) in self.program.data_segments_start.iter_enumerated() {
            let mark = self.marks.allocate_mark();
            self.data_marks.insert(segment_id, mark);
        }

        // Generate init code first
        self.generate_init_code()?;

        // Mark where init ends and runtime begins
        self.asm.push(Asm::Mark(self.init_end_mark));

        // Generate runtime code
        self.generate_runtime_code()?;

        // Mark where runtime ends
        self.asm.push(Asm::Mark(self.runtime_end_mark));

        // Translate any remaining untranslated blocks (e.g., from internal calls)
        for block_idx in 0..self.program.basic_blocks.len() {
            let block_id = BasicBlockId::from_usize(block_idx);
            if !self.translated_blocks.contains(&block_id) {
                self.translate_block(block_id)?;
            }
        }

        // Embed data segments
        self.embed_data_segments();

        // Mark the end of all data
        self.asm.push(Asm::Mark(self.data_end_mark));

        Ok(())
    }

    /// Generate init code
    fn generate_init_code(&mut self) -> Result<()> {
        // Initialize EVM state
        self.emit_initialization();

        // Set flag to track we're translating init code
        self.is_translating_init = true;

        // Translate init_entry function
        let init_entry_block = self.program.functions[self.program.init_entry].entry;
        let init_func_mark = self.marks.get_function_mark(self.program.init_entry);
        self.emit_mark(init_func_mark);
        self.translate_block(init_entry_block)?;

        // Clear the init translation flag
        self.is_translating_init = false;

        // Always add deployment return if init code didn't have its own RETURN
        // This ensures the runtime code is deployed properly
        if !self.init_has_return {
            self.emit_deployment_return();
        }

        Ok(())
    }

    /// Generate runtime code
    fn generate_runtime_code(&mut self) -> Result<()> {
        // If there's a main entry, translate it
        if let Some(main_entry) = self.program.main_entry {
            let main_entry_block = self.program.functions[main_entry].entry;
            let main_mark = self.marks.get_function_mark(main_entry);
            self.emit_mark(main_mark);
            self.translate_block(main_entry_block)?;
        }
        Ok(())
    }

    /// Emit deployment return (copies runtime+data and returns it)
    fn emit_deployment_return(&mut self) {
        use evm_glue::opcodes::Opcode;

        // PUSH 0 (memory destination)
        self.push_const(U256::from(0));

        // PUSH runtime_start (source in code)
        self.asm.push(Asm::Ref(MarkRef {
            ref_type: RefType::Direct(self.runtime_start_mark),
            is_pushed: true,
            set_size: None,
        }));

        // PUSH size (runtime + data length)
        // Calculate the actual size from runtime_start to data_end
        self.asm.push(Asm::Ref(MarkRef {
            ref_type: RefType::Delta(self.data_end_mark, self.runtime_start_mark),
            is_pushed: true,
            set_size: None,
        }));

        // CODECOPY
        self.asm.push(Asm::Op(Opcode::CODECOPY));

        // PUSH 0 (memory offset for return)
        self.push_const(U256::from(0));

        // PUSH size again for RETURN
        self.asm.push(Asm::Ref(MarkRef {
            ref_type: RefType::Delta(self.data_end_mark, self.runtime_start_mark),
            is_pushed: true,
            set_size: None,
        }));

        // RETURN
        self.asm.push(Asm::Op(Opcode::RETURN));
    }

    /// Embed data segments at the end of bytecode
    fn embed_data_segments(&mut self) {
        for (segment_id, _) in self.program.data_segments_start.iter_enumerated() {
            // Place mark for this segment
            if let Some(&mark) = self.data_marks.get(&segment_id) {
                self.asm.push(Asm::Mark(mark));
            }

            // Get segment bytes and embed as raw data
            let range = self.program.get_segment_range(segment_id);
            let segment_size = (range.end.get() - range.start.get()) as usize;

            if segment_size > 0 {
                // Use SmallVec for small segments (< 256 bytes), Vec for larger
                if segment_size <= 256 {
                    let mut bytes: SmallVec<[u8; 256]> = SmallVec::with_capacity(segment_size);
                    for i in range.start.get()..range.end.get() {
                        bytes.push(self.program.data_bytes[eth_ir_data::DataOffset::new(i)]);
                    }
                    self.asm.push(Asm::Data(bytes.to_vec()));
                } else {
                    let mut bytes = Vec::with_capacity(segment_size);
                    for i in range.start.get()..range.end.get() {
                        bytes.push(self.program.data_bytes[eth_ir_data::DataOffset::new(i)]);
                    }
                    self.asm.push(Asm::Data(bytes));
                }
            }
        }
    }

    /// Emit initialization code for the EVM
    fn emit_initialization(&mut self) {
        use evm_glue::opcodes::Opcode;

        // Set up the free memory pointer at 0x40
        // The free memory pointer points to the start of free memory
        // We set it to point just after our locals area

        // Get the actual calculated free memory start address
        let free_mem_start = self.memory.get_free_memory_start();

        // PUSH free_mem_start
        self.push_const(U256::from(free_mem_start));

        // PUSH 0x40 (free memory pointer location)
        self.push_const(U256::from(memory::constants::FREE_MEM_PTR));

        // MSTORE
        self.asm.push(Asm::Op(Opcode::MSTORE));
    }

    /// Pre-allocate memory for all locals in the program
    fn allocate_all_locals(&mut self) {
        // The program.locals is an arena/pool of LocalId references
        // Multiple entries might reference the same LocalId
        // We need to allocate memory for each UNIQUE LocalId

        // Collect unique LocalIds
        // Pre-allocate based on locals count (worst case: all are unique)
        let mut seen = std::collections::HashSet::with_capacity(self.program.locals.len());
        for local_id in self.program.locals.iter() {
            if seen.insert(*local_id) {
                // First time seeing this LocalId, allocate memory for it
                self.memory.allocate_local(*local_id);
            }
        }
    }

    /// Get the generated assembly
    pub fn into_asm(self) -> Vec<Asm> {
        self.asm
    }

    /// Translate a basic block
    fn translate_block(&mut self, block_id: BasicBlockId) -> Result<()> {
        // Check if we've already translated this block
        if !self.translated_blocks.insert(block_id) {
            // Already translated, nothing to do
            return Ok(());
        }

        // Check if block exists
        if block_id.index() >= self.program.basic_blocks.len() {
            return Err(CodegenError::InvalidBlockReference { block: block_id });
        }

        // Extract block data to avoid borrowing issues
        let block = &self.program.basic_blocks[block_id];
        let operations_range = block.operations.clone();
        let control = block.control.clone();

        // Emit the block's mark (label)
        let block_mark = self.marks.get_block_mark(block_id);
        self.emit_mark(block_mark);

        // Handle block inputs
        // In our memory-backed approach, inputs are already in memory
        // from the caller, so we don't need to do anything special

        // Translate all operations in the block
        // Clone operations to avoid borrowing conflicts
        // Use SmallVec since most blocks have < 32 operations
        let ops_to_translate: SmallVec<[_; 32]> =
            self.program.operations[operations_range].iter().cloned().collect();
        for op in ops_to_translate {
            self.translate_operation(&op)?;
        }

        // Handle block outputs
        // In our memory-backed approach, outputs are already in memory
        // after operations execute, so nothing special needed

        // Translate control flow
        self.translate_control(&control)?;

        // Recursively translate reachable blocks
        match &control {
            Control::ContinuesTo(next) => {
                self.translate_block(*next)?;
            }
            Control::Branches(branch) => {
                self.translate_block(branch.zero_target)?;
                self.translate_block(branch.non_zero_target)?;
            }
            Control::Switch(switch) => {
                // Check if cases array exists
                if switch.cases.index() >= self.program.cases.len() {
                    return Err(CodegenError::InvalidCasesReference { cases: switch.cases });
                }
                // Translate all case targets
                // Pre-allocate with exact size since we know the count
                let cases = &self.program.cases[switch.cases].cases;
                let mut case_targets = Vec::with_capacity(cases.len());
                for case in cases {
                    case_targets.push(case.target);
                }
                for target in case_targets {
                    self.translate_block(target)?;
                }
                if let Some(fallback) = switch.fallback {
                    self.translate_block(fallback)?;
                }
            }
            Control::LastOpTerminates | Control::InternalReturn => {
                // These don't continue to other blocks
            }
        }

        Ok(())
    }

    /// Translate a two-argument operation to EVM assembly
    ///
    /// Handles the common pattern of loading two arguments from memory, executing an opcode,
    /// and storing the result back to memory. Many EVM operations expect arguments in
    /// reverse order on the stack compared to how they appear in expressions.
    ///
    /// # Arguments
    /// * `two_in_one` - The IR operation with two inputs and one output
    /// * `opcode` - The EVM opcode to execute
    /// * `reversed` - If true, reverses argument order for operations like SUB, DIV, MOD
    /// # Stack Effects
    /// * When `reversed=false`: pushes arg1, then arg2 → opcode expects [arg1, arg2]
    /// * When `reversed=true`: pushes arg2, then arg1 → opcode expects [arg2, arg1]
    ///
    /// # Examples
    /// * ADD(a, b) uses reversed=false: a + b
    /// * SUB(a, b) uses reversed=true: a - b (EVM does: second_on_stack - top_of_stack)
    fn translate_two_arg_op(
        &mut self,
        two_in_one: &eth_ir_data::operation::TwoInOneOut,
        opcode: evm_glue::opcodes::Opcode,
        reversed: bool,
    ) -> Result<()> {
        if reversed {
            self.load_local(two_in_one.arg2)?;
            self.load_local(two_in_one.arg1)?;
        } else {
            self.load_local(two_in_one.arg1)?;
            self.load_local(two_in_one.arg2)?;
        }
        self.asm.push(Asm::Op(opcode));
        self.store_local(two_in_one.result)?;
        Ok(())
    }

    /// Translate a one-argument operation to EVM assembly
    ///
    /// Handles the common pattern of loading one argument from memory,
    /// executing a unary opcode, and storing the result back to memory.
    ///
    /// # Arguments
    /// * `one_in_one` - The IR operation with one input and one output
    /// * `opcode` - The EVM opcode to execute (e.g., NOT, ISZERO)
    ///
    /// # Stack Effects
    /// 1. Loads arg1 from memory → stack: [arg1]
    /// 2. Executes opcode → stack: [result]
    /// 3. Stores result to memory → stack: []
    fn translate_one_arg_op(
        &mut self,
        one_in_one: &eth_ir_data::operation::OneInOneOut,
        opcode: evm_glue::opcodes::Opcode,
    ) -> Result<()> {
        self.load_local(one_in_one.arg1)?;
        self.asm.push(Asm::Op(opcode));
        self.store_local(one_in_one.result)?;
        Ok(())
    }

    /// Translate a single IR operation to EVM assembly
    ///
    /// This is the main dispatch function that translates each IR operation type
    /// into the corresponding EVM opcodes. It handles arithmetic, logic, memory,
    /// storage, control flow, and all other EVM operations.
    ///
    /// # Arguments
    /// * `op` - The IR operation to translate
    ///
    /// # Operation Categories
    /// * Arithmetic: ADD, SUB, MUL, DIV, MOD, etc.
    /// * Bitwise: AND, OR, XOR, NOT, SHL, SHR, etc.
    /// * Comparison: LT, GT, EQ, ISZERO, etc.
    /// * Memory: Load, Store, Copy
    /// * Storage: SLOAD, SSTORE
    /// * Environmental: ADDRESS, CALLER, CALLVALUE, etc.
    /// * Calls: CALL, STATICCALL, DELEGATECALL, CREATE
    /// * Control: Internal calls, returns
    /// * Data: Constants, data segments
    fn translate_operation(&mut self, op: &eth_ir_data::Operation) -> Result<()> {
        use eth_ir_data::Operation;
        use evm_glue::opcodes::Opcode;

        match op {
            // Arithmetic operations
            Operation::Add(two_in_one) => {
                self.translate_two_arg_op(two_in_one, Opcode::ADD, false)?
            }

            Operation::Sub(two_in_one) => {
                // SUB computes: top - deeper
                // To compute arg1 - arg2, push arg2 first, arg1 second
                self.translate_two_arg_op(two_in_one, Opcode::SUB, true)?
            }

            Operation::Mul(two_in_one) => {
                self.translate_two_arg_op(two_in_one, Opcode::MUL, false)?
            }

            Operation::Div(two_in_one) => {
                // DIV computes: top / deeper
                // To compute arg1 / arg2, push arg2 first, arg1 second
                self.translate_two_arg_op(two_in_one, Opcode::DIV, true)?
            }

            Operation::SDiv(two_in_one) => {
                // SDIV computes: top / deeper (signed)
                self.translate_two_arg_op(two_in_one, Opcode::SDIV, true)?
            }

            Operation::Mod(two_in_one) => {
                // MOD computes: top % deeper
                // To compute arg1 % arg2, push arg2 first, arg1 second
                self.translate_two_arg_op(two_in_one, Opcode::MOD, true)?
            }

            Operation::SMod(two_in_one) => {
                // SMOD computes: top % deeper (signed)
                self.translate_two_arg_op(two_in_one, Opcode::SMOD, true)?
            }

            Operation::Exp(two_in_one) => {
                // EXP pops: base, exponent and computes base^exponent
                // So we need to push in reverse: exponent, base
                self.translate_two_arg_op(two_in_one, Opcode::EXP, true)?
            }

            Operation::SignExtend(two_in_one) => {
                // SIGNEXTEND takes byte_position (top) and value (second)
                // arg1 is byte_position, arg2 is value
                self.load_local(two_in_one.arg2)?; // value (deeper)
                self.load_local(two_in_one.arg1)?; // byte_position (top)
                self.asm.push(Asm::Op(Opcode::SIGNEXTEND));
                self.store_local(two_in_one.result)?;
            }

            Operation::AddMod(large_in_one) => {
                // ADDMOD pops: a, b, N and computes (a + b) % N
                // So we need to push in reverse: N, b, a
                let args = large_in_one.get_args(&self.program.locals);
                self.load_local(args[2])?; // N (modulus) - pushed first, popped last
                self.load_local(args[1])?; // b - pushed second
                self.load_local(args[0])?; // a - pushed last, popped first
                self.asm.push(Asm::Op(Opcode::ADDMOD));
                self.store_local(large_in_one.result)?;
            }

            Operation::MulMod(large_in_one) => {
                // MULMOD pops: a, b, N and computes (a * b) % N
                // So we need to push in reverse: N, b, a
                let args = large_in_one.get_args(&self.program.locals);
                self.load_local(args[2])?; // N (modulus) - pushed first, popped last
                self.load_local(args[1])?; // b - pushed second
                self.load_local(args[0])?; // a - pushed last, popped first
                self.asm.push(Asm::Op(Opcode::MULMOD));
                self.store_local(large_in_one.result)?;
            }

            // Bitwise operations
            Operation::And(two_in_one) => {
                self.translate_two_arg_op(two_in_one, Opcode::AND, false)?
            }

            Operation::Or(two_in_one) => {
                self.translate_two_arg_op(two_in_one, Opcode::OR, false)?
            }

            Operation::Xor(two_in_one) => {
                self.translate_two_arg_op(two_in_one, Opcode::XOR, false)?
            }

            Operation::Not(one_in_one) => self.translate_one_arg_op(one_in_one, Opcode::NOT)?,

            Operation::Byte(two_in_one) => {
                // BYTE takes position (top) and value (second)
                // arg1 is position, arg2 is value
                self.translate_two_arg_op(two_in_one, Opcode::BYTE, true)?
            }

            Operation::Shl(two_in_one) => {
                // SHL takes shift amount (top) and value (second)
                // arg1 is shift amount, arg2 is value
                self.translate_two_arg_op(two_in_one, Opcode::SHL, true)?
            }

            Operation::Shr(two_in_one) => {
                // SHR takes shift amount (top) and value (second)
                // arg1 is shift amount, arg2 is value
                self.translate_two_arg_op(two_in_one, Opcode::SHR, true)?
            }

            Operation::Sar(two_in_one) => {
                // SAR takes shift amount (top) and value (second)
                // arg1 is shift amount, arg2 is value
                self.translate_two_arg_op(two_in_one, Opcode::SAR, true)?
            }

            // Hash operations
            Operation::Keccak256(two_in_one) => {
                // Keccak256 hash of memory region
                // arg1 = offset, arg2 = size, result = hash
                // Note: EVM opcode is called SHA3 for historical reasons, but it's actually
                // Keccak256
                self.translate_two_arg_op(two_in_one, Opcode::SHA3, false)?
            }

            // Comparison operations
            Operation::Lt(two_in_one) => {
                // LT computes: a < b where a is top, b is second
                // To compute arg1 < arg2, push arg2 first, arg1 second (so arg1 is on top)
                self.translate_two_arg_op(two_in_one, Opcode::LT, true)?
            }

            Operation::Gt(two_in_one) => {
                // GT computes: a > b where a is top, b is second
                // To compute arg1 > arg2, push arg2 first, arg1 second (so arg1 is on top)
                self.translate_two_arg_op(two_in_one, Opcode::GT, true)?
            }

            Operation::SLt(two_in_one) => {
                // SLT computes: a < b (signed) where a is top, b is second
                // To compute arg1 < arg2, push arg2 first, arg1 second (so arg1 is on top)
                self.translate_two_arg_op(two_in_one, Opcode::SLT, true)?
            }

            Operation::SGt(two_in_one) => {
                // SGT computes: a > b (signed) where a is top, b is second
                // To compute arg1 > arg2, push arg2 first, arg1 second (so arg1 is on top)
                self.translate_two_arg_op(two_in_one, Opcode::SGT, true)?
            }

            Operation::Eq(two_in_one) => {
                self.translate_two_arg_op(two_in_one, Opcode::EQ, false)?
            }

            Operation::IsZero(one_in_one) => {
                self.translate_one_arg_op(one_in_one, Opcode::ISZERO)?
            }

            // Local assignment
            Operation::LocalSet(one_in_one) => {
                self.load_local(one_in_one.arg1)?;
                self.store_local(one_in_one.result)?;
            }

            // Set local to small constant
            Operation::LocalSetSmallConst(set_const) => {
                self.push_const(U256::from(set_const.value));
                self.store_local(set_const.local)?;
            }

            // Set local to large constant from the constants array
            Operation::LocalSetLargeConst(set_large) => {
                // Check if the constant exists
                if set_large.cid.index() >= self.program.large_consts.len() {
                    return Err(CodegenError::InvalidLargeConstReference {
                        constant: set_large.cid,
                    });
                }
                // Get the constant from the large_consts array
                let value = self.program.large_consts[set_large.cid];
                self.push_const(value);
                self.store_local(set_large.local)?;
            }

            // External call operations
            Operation::Call(large_in_one) => {
                // CALL takes 7 args: gas, address, value, argsOffset, argsSize, retOffset, retSize
                self.validate_local_range(large_in_one.args_start.get() as usize, 7)?;
                let args = large_in_one.get_args(&self.program.locals);
                self.load_local(args[0])?; // gas
                self.load_local(args[1])?; // address
                self.load_local(args[2])?; // value
                self.load_local(args[3])?; // argsOffset
                self.load_local(args[4])?; // argsSize
                self.load_local(args[5])?; // retOffset
                self.load_local(args[6])?; // retSize
                self.asm.push(Asm::Op(Opcode::CALL));
                self.store_local(large_in_one.result)?; // Store success (0 or 1)
            }

            Operation::CallCode(large_in_one) => {
                // CALLCODE takes 7 args: gas, address, value, argsOffset, argsSize, retOffset,
                // retSize
                let args = large_in_one.get_args(&self.program.locals);
                self.load_local(args[0])?; // gas
                self.load_local(args[1])?; // address
                self.load_local(args[2])?; // value
                self.load_local(args[3])?; // argsOffset
                self.load_local(args[4])?; // argsSize
                self.load_local(args[5])?; // retOffset
                self.load_local(args[6])?; // retSize
                self.asm.push(Asm::Op(Opcode::CALLCODE));
                self.store_local(large_in_one.result)?; // Store success (0 or 1)
            }

            Operation::DelegateCall(large_in_one) => {
                // DELEGATECALL takes 6 args: gas, address, argsOffset, argsSize, retOffset, retSize
                let args = large_in_one.get_args(&self.program.locals);
                self.load_local(args[0])?; // gas
                self.load_local(args[1])?; // address
                self.load_local(args[2])?; // argsOffset
                self.load_local(args[3])?; // argsSize
                self.load_local(args[4])?; // retOffset
                self.load_local(args[5])?; // retSize
                self.asm.push(Asm::Op(Opcode::DELEGATECALL));
                self.store_local(large_in_one.result)?; // Store success (0 or 1)
            }

            Operation::StaticCall(large_in_one) => {
                // STATICCALL takes 6 args: gas, address, argsOffset, argsSize, retOffset, retSize
                let args = large_in_one.get_args(&self.program.locals);
                self.load_local(args[0])?; // gas
                self.load_local(args[1])?; // address
                self.load_local(args[2])?; // argsOffset
                self.load_local(args[3])?; // argsSize
                self.load_local(args[4])?; // retOffset
                self.load_local(args[5])?; // retSize
                self.asm.push(Asm::Op(Opcode::STATICCALL));
                self.store_local(large_in_one.result)?; // Store success (0 or 1)
            }

            // Internal call operations
            Operation::InternalCall(call) => {
                // TODO: Update calling convention for stack window approach
                // Future: Args will be in stack window slots, not memory
                // For now: Use memory-backed approach but structure it to be compatible

                // Create a mark for the return point
                let return_mark = self.marks.allocate_mark();

                // Save return address to memory (future: will stay on stack)
                // Using 0x60 as return address slot (ZERO_SLOT in memory layout)
                self.asm.push(Asm::Ref(MarkRef {
                    ref_type: RefType::Direct(return_mark),
                    is_pushed: true,
                    set_size: None,
                }));
                self.push_const(U256::from(memory::constants::ZERO_SLOT));
                self.asm.push(Asm::Op(Opcode::MSTORE));

                // Arguments are already in memory at args_start
                // Future: Will be in stack window, copied/spilled as needed

                // Jump to the function's entry block
                let func_entry_block = self.program.functions[call.function].entry;
                let block_mark = self.marks.get_block_mark(func_entry_block);
                self.emit_jump(block_mark);

                // Emit the return point mark
                self.emit_mark(return_mark);

                // After return, outputs will be in memory at outputs_start
                // Future: Will be in stack window slots
            }

            // Return operation
            Operation::Return(two_in_zero) => {
                // If we're translating init code, mark that we've seen a RETURN
                if self.is_translating_init {
                    self.init_has_return = true;
                }
                // RETURN expects offset on top of stack, size below
                self.load_local(two_in_zero.arg2)?; // size
                self.load_local(two_in_zero.arg1)?; // offset
                self.asm.push(Asm::Op(Opcode::RETURN));
            }

            // Environmental information operations
            Operation::Address(zero_in_one) => {
                // Get address of currently executing contract
                self.asm.push(Asm::Op(Opcode::ADDRESS));
                self.store_local(zero_in_one.result)?;
            }

            Operation::Caller(zero_in_one) => {
                // Get caller address (msg.sender)
                self.asm.push(Asm::Op(Opcode::CALLER));
                self.store_local(zero_in_one.result)?;
            }

            Operation::Origin(zero_in_one) => {
                // Get transaction origin (tx.origin)
                self.asm.push(Asm::Op(Opcode::ORIGIN));
                self.store_local(zero_in_one.result)?;
            }

            Operation::CallValue(zero_in_one) => {
                // Get msg.value (wei sent with call)
                self.asm.push(Asm::Op(Opcode::CALLVALUE));
                self.store_local(zero_in_one.result)?;
            }

            Operation::CallDataSize(zero_in_one) => {
                // Get size of calldata
                self.asm.push(Asm::Op(Opcode::CALLDATASIZE));
                self.store_local(zero_in_one.result)?;
            }

            Operation::GasPrice(zero_in_one) => {
                // Get gas price of transaction
                self.asm.push(Asm::Op(Opcode::GASPRICE));
                self.store_local(zero_in_one.result)?;
            }

            Operation::Gas(zero_in_one) => {
                // Get remaining gas
                self.asm.push(Asm::Op(Opcode::GAS));
                self.store_local(zero_in_one.result)?;
            }

            Operation::Balance(one_in_one) => {
                // Get balance of address
                self.load_local(one_in_one.arg1)?;
                self.asm.push(Asm::Op(Opcode::BALANCE));
                self.store_local(one_in_one.result)?;
            }

            Operation::CallDataLoad(one_in_one) => {
                // Load word from calldata at offset
                self.load_local(one_in_one.arg1)?;
                self.asm.push(Asm::Op(Opcode::CALLDATALOAD));
                self.store_local(one_in_one.result)?;
            }

            Operation::ExtCodeSize(one_in_one) => {
                // Get code size of external contract
                self.load_local(one_in_one.arg1)?;
                self.asm.push(Asm::Op(Opcode::EXTCODESIZE));
                self.store_local(one_in_one.result)?;
            }

            Operation::ExtCodeHash(one_in_one) => {
                // Get code hash of external contract
                self.load_local(one_in_one.arg1)?;
                self.asm.push(Asm::Op(Opcode::EXTCODEHASH));
                self.store_local(one_in_one.result)?;
            }

            // Block information operations
            Operation::Coinbase(zero_in_one) => {
                // Get block coinbase (miner) address
                self.asm.push(Asm::Op(Opcode::COINBASE));
                self.store_local(zero_in_one.result)?;
            }

            Operation::Timestamp(zero_in_one) => {
                // Get block timestamp
                self.asm.push(Asm::Op(Opcode::TIMESTAMP));
                self.store_local(zero_in_one.result)?;
            }

            Operation::Number(zero_in_one) => {
                // Get block number
                self.asm.push(Asm::Op(Opcode::NUMBER));
                self.store_local(zero_in_one.result)?;
            }

            Operation::Difficulty(zero_in_one) => {
                // Get block difficulty (prevrandao after merge)
                self.asm.push(Asm::Op(Opcode::PREVRANDAO));
                self.store_local(zero_in_one.result)?;
            }

            Operation::GasLimit(zero_in_one) => {
                // Get block gas limit
                self.asm.push(Asm::Op(Opcode::GASLIMIT));
                self.store_local(zero_in_one.result)?;
            }

            Operation::ChainId(zero_in_one) => {
                // Get chain ID
                self.asm.push(Asm::Op(Opcode::CHAINID));
                self.store_local(zero_in_one.result)?;
            }

            Operation::SelfBalance(zero_in_one) => {
                // Get balance of current contract
                self.asm.push(Asm::Op(Opcode::SELFBALANCE));
                self.store_local(zero_in_one.result)?;
            }

            Operation::BaseFee(zero_in_one) => {
                // Get base fee
                self.asm.push(Asm::Op(Opcode::BASEFEE));
                self.store_local(zero_in_one.result)?;
            }

            Operation::BlobBaseFee(zero_in_one) => {
                // Get blob base fee
                self.asm.push(Asm::Op(Opcode::BLOBBASEFEE));
                self.store_local(zero_in_one.result)?;
            }

            Operation::BlockHash(one_in_one) => {
                // Get block hash for given block number
                self.load_local(one_in_one.arg1)?;
                self.asm.push(Asm::Op(Opcode::BLOCKHASH));
                self.store_local(one_in_one.result)?;
            }

            Operation::BlobHash(one_in_one) => {
                // Get blob hash at index
                self.load_local(one_in_one.arg1)?;
                self.asm.push(Asm::Op(Opcode::BLOBHASH));
                self.store_local(one_in_one.result)?;
            }

            // Storage operations
            Operation::SLoad(one_in_one) => {
                // Load value from storage
                self.load_local(one_in_one.arg1)?; // storage key
                self.asm.push(Asm::Op(Opcode::SLOAD));
                self.store_local(one_in_one.result)?;
            }

            Operation::SStore(two_in_zero) => {
                // Store value to storage
                self.load_local(two_in_zero.arg1)?; // storage key
                self.load_local(two_in_zero.arg2)?; // value
                self.asm.push(Asm::Op(Opcode::SSTORE));
            }

            Operation::TLoad(one_in_one) => {
                // Load value from transient storage
                self.load_local(one_in_one.arg1)?; // storage key
                self.asm.push(Asm::Op(Opcode::TLOAD));
                self.store_local(one_in_one.result)?;
            }

            Operation::TStore(two_in_zero) => {
                // Store value to transient storage
                self.load_local(two_in_zero.arg1)?; // storage key
                self.load_local(two_in_zero.arg2)?; // value
                self.asm.push(Asm::Op(Opcode::TSTORE));
            }

            // Logging operations
            Operation::Log0(two_in_zero) => {
                // LOG0: offset, size
                self.load_local(two_in_zero.arg1)?; // memory offset
                self.load_local(two_in_zero.arg2)?; // size
                self.asm.push(Asm::Op(Opcode::LOG0));
            }

            Operation::Log1(three_in_zero) => {
                // LOG1 expects stack: [topic, size, offset] (from bottom to top)
                self.load_local(three_in_zero.arg3)?; // topic1
                self.load_local(three_in_zero.arg2)?; // size
                self.load_local(three_in_zero.arg1)?; // memory offset
                self.asm.push(Asm::Op(Opcode::LOG1));
            }

            Operation::Log2(large_in_zero) => {
                // LOG2 expects stack: [topic2, topic1, size, offset] (from bottom to top)
                let args = large_in_zero.get_args(&self.program.locals);
                self.load_local(args[3])?; // topic2
                self.load_local(args[2])?; // topic1
                self.load_local(args[1])?; // size
                self.load_local(args[0])?; // memory offset
                self.asm.push(Asm::Op(Opcode::LOG2));
            }

            Operation::Log3(large_in_zero) => {
                // LOG3 expects stack: [topic3, topic2, topic1, size, offset] (from bottom to top)
                let args = large_in_zero.get_args(&self.program.locals);
                self.load_local(args[4])?; // topic3
                self.load_local(args[3])?; // topic2
                self.load_local(args[2])?; // topic1
                self.load_local(args[1])?; // size
                self.load_local(args[0])?; // memory offset
                self.asm.push(Asm::Op(Opcode::LOG3));
            }

            Operation::Log4(large_in_zero) => {
                // LOG4 expects stack: [topic4, topic3, topic2, topic1, size, offset] (from bottom
                // to top)
                let args = large_in_zero.get_args(&self.program.locals);
                self.load_local(args[5])?; // topic4
                self.load_local(args[4])?; // topic3
                self.load_local(args[3])?; // topic2
                self.load_local(args[2])?; // topic1
                self.load_local(args[1])?; // size
                self.load_local(args[0])?; // memory offset
                self.asm.push(Asm::Op(Opcode::LOG4));
            }

            // Error handling
            Operation::Revert(two_in_zero) => {
                // REVERT expects offset on top of stack, size below
                self.load_local(two_in_zero.arg2)?; // size
                self.load_local(two_in_zero.arg1)?; // offset
                self.asm.push(Asm::Op(Opcode::REVERT));
            }

            // Contract creation and destruction
            Operation::Create(large_in_one) => {
                // CREATE: value, offset, size
                let args = large_in_one.get_args(&self.program.locals);
                self.load_local(args[0])?; // value to send
                self.load_local(args[1])?; // memory offset of init code
                self.load_local(args[2])?; // size of init code
                self.asm.push(Asm::Op(Opcode::CREATE));
                self.store_local(large_in_one.result)?; // new contract address (or 0 on failure)
            }

            Operation::Create2(large_in_one) => {
                // CREATE2: value, offset, size, salt
                let args = large_in_one.get_args(&self.program.locals);
                self.load_local(args[0])?; // value to send
                self.load_local(args[1])?; // memory offset of init code
                self.load_local(args[2])?; // size of init code
                self.load_local(args[3])?; // salt
                self.asm.push(Asm::Op(Opcode::CREATE2));
                self.store_local(large_in_one.result)?; // new contract address (or 0 on failure)
            }

            Operation::SelfDestruct(one_in_zero) => {
                // SELFDESTRUCT: beneficiary address
                self.load_local(one_in_zero.arg1)?; // beneficiary
                self.asm.push(Asm::Op(Opcode::SELFDESTRUCT));
            }

            // Simple operations
            Operation::CodeSize(zero_in_one) => {
                // Get size of current contract's code
                self.asm.push(Asm::Op(Opcode::CODESIZE));
                self.store_local(zero_in_one.result)?;
            }

            Operation::ReturnDataSize(zero_in_one) => {
                // Get size of return data from last call
                self.asm.push(Asm::Op(Opcode::RETURNDATASIZE));
                self.store_local(zero_in_one.result)?;
            }

            // Copy operations
            Operation::CallDataCopy(three_in_zero) => {
                // Copy calldata to memory: destOffset, dataOffset, size
                self.load_local(three_in_zero.arg1)?; // memory destination offset
                self.load_local(three_in_zero.arg2)?; // calldata source offset
                self.load_local(three_in_zero.arg3)?; // size
                self.asm.push(Asm::Op(Opcode::CALLDATACOPY));
            }

            Operation::CodeCopy(three_in_zero) => {
                // Copy code to memory: destOffset, codeOffset, size
                self.load_local(three_in_zero.arg1)?; // memory destination offset
                self.load_local(three_in_zero.arg2)?; // code source offset
                self.load_local(three_in_zero.arg3)?; // size
                self.asm.push(Asm::Op(Opcode::CODECOPY));
            }

            Operation::ReturnDataCopy(three_in_zero) => {
                // Copy return data to memory: destOffset, dataOffset, size
                self.load_local(three_in_zero.arg1)?; // memory destination offset
                self.load_local(three_in_zero.arg2)?; // return data source offset
                self.load_local(three_in_zero.arg3)?; // size
                self.asm.push(Asm::Op(Opcode::RETURNDATACOPY));
            }

            Operation::ExtCodeCopy(large_in_zero) => {
                // Copy external contract code to memory: address, destOffset, codeOffset, size
                let args = large_in_zero.get_args(&self.program.locals);
                self.load_local(args[0])?; // external contract address
                self.load_local(args[1])?; // memory destination offset
                self.load_local(args[2])?; // code source offset
                self.load_local(args[3])?; // size
                self.asm.push(Asm::Op(Opcode::EXTCODECOPY));
            }

            Operation::MCopy(three_in_zero) => {
                // Memory to memory copy: destOffset, srcOffset, size
                self.load_local(three_in_zero.arg1)?; // destination offset
                self.load_local(three_in_zero.arg2)?; // source offset
                self.load_local(three_in_zero.arg3)?; // size
                self.asm.push(Asm::Op(Opcode::MCOPY));
            }

            Operation::NoOp => {
                // No operation - do nothing
            }

            // Terminal operations
            Operation::Stop => {
                self.asm.push(Asm::Op(Opcode::STOP));
            }

            Operation::Invalid => {
                self.asm.push(Asm::Op(Opcode::INVALID));
            }

            // Bytecode introspection operations
            Operation::RuntimeStartOffset(zero_in_one) => {
                // Push byte offset where runtime starts in deployment bytecode
                self.asm.push(Asm::Ref(MarkRef {
                    ref_type: RefType::Direct(self.runtime_start_mark),
                    is_pushed: true,
                    set_size: None,
                }));
                self.store_local(zero_in_one.result)?;
            }

            Operation::InitEndOffset(zero_in_one) => {
                // Push byte offset where init code ends
                self.asm.push(Asm::Ref(MarkRef {
                    ref_type: RefType::Direct(self.init_end_mark),
                    is_pushed: true,
                    set_size: None,
                }));
                self.store_local(zero_in_one.result)?;
            }

            Operation::RuntimeLength(zero_in_one) => {
                // Push length of runtime code (not including data)
                // This is a Delta reference: runtime_end - runtime_start
                self.asm.push(Asm::Ref(MarkRef {
                    ref_type: RefType::Delta(self.runtime_end_mark, self.runtime_start_mark),
                    is_pushed: true,
                    set_size: None,
                }));
                self.store_local(zero_in_one.result)?;
            }

            // Data segment reference
            Operation::LocalSetDataOffset(set) => {
                // Push the byte offset of this data segment
                let mark = self
                    .data_marks
                    .get(&set.segment_id)
                    .copied()
                    .ok_or(CodegenError::DataSegmentNotFound { segment: set.segment_id })?;

                self.asm.push(Asm::Ref(MarkRef {
                    ref_type: RefType::Direct(mark),
                    is_pushed: true,
                    set_size: None,
                }));

                self.store_local(set.local)?;
            }

            // Memory management
            Operation::AcquireFreePointer(zero_in_one) => {
                // Load free memory pointer from 0x40
                self.push_const(U256::from(memory::constants::FREE_MEM_PTR));
                self.asm.push(Asm::Op(Opcode::MLOAD));
                self.store_local(zero_in_one.result)?;
            }

            Operation::DynamicAllocZeroed(one_in_one) => {
                // Allocate memory and zero it
                // Input: size, Output: pointer to allocated memory

                // Load current free memory pointer
                self.push_const(U256::from(memory::constants::FREE_MEM_PTR));
                self.asm.push(Asm::Op(Opcode::DUP1)); // Duplicate for later use
                self.asm.push(Asm::Op(Opcode::MLOAD)); // Load current free pointer
                self.asm.push(Asm::Op(Opcode::DUP1)); // This will be our return value

                // Calculate new free pointer (current + size)
                self.load_local(one_in_one.arg1)?; // Load size
                self.asm.push(Asm::Op(Opcode::DUP1)); // Keep size for zeroing
                self.asm.push(Asm::Op(Opcode::DUP3)); // Get current pointer
                self.asm.push(Asm::Op(Opcode::ADD)); // new_ptr = current + size

                // Store new free pointer
                self.asm.push(Asm::Op(Opcode::SWAP3)); // Move 0x40 to near top
                self.asm.push(Asm::Op(Opcode::MSTORE)); // Store new free pointer

                // Stack now: [ptr, size]
                // Zero out memory with a simple loop (32 bytes at a time)

                // Create loop marks
                let loop_start = self.marks.allocate_mark();
                let loop_end = self.marks.allocate_mark();

                // Calculate end pointer (ptr + size)
                self.asm.push(Asm::Op(Opcode::DUP1)); // [ptr, ptr, size]
                self.asm.push(Asm::Op(Opcode::DUP3)); // [size, ptr, ptr, size]
                self.asm.push(Asm::Op(Opcode::ADD)); // [end_ptr, ptr, size]

                // Stack: [end_ptr, ptr, size]
                // Swap to get [ptr, end_ptr, size] for loop
                self.asm.push(Asm::Op(Opcode::SWAP1)); // [ptr, end_ptr, size]

                // Loop start
                self.emit_mark(loop_start);

                // Stack: [current_ptr, end_ptr, size]
                // Check if we've reached the end
                self.asm.push(Asm::Op(Opcode::DUP2)); // [end_ptr, current_ptr, end_ptr, size]
                self.asm.push(Asm::Op(Opcode::DUP2)); // [current_ptr, end_ptr, current_ptr, end_ptr, size]
                self.asm.push(Asm::Op(Opcode::LT)); // [current < end, current_ptr, end_ptr, size]
                self.asm.push(Asm::Op(Opcode::ISZERO)); // [current >= end, current_ptr, end_ptr, size]
                self.emit_jumpi(loop_end);

                // Store 32 bytes of zeros at current position
                self.asm.push(Asm::Op(Opcode::PUSH0)); // [0, current_ptr, end_ptr, size]
                self.asm.push(Asm::Op(Opcode::DUP2)); // [current_ptr, 0, current_ptr, end_ptr, size]
                self.asm.push(Asm::Op(Opcode::MSTORE)); // Write 32 zero bytes

                // Move to next 32-byte chunk
                self.push_const(U256::from(32)); // [32, current_ptr, end_ptr, size]
                self.asm.push(Asm::Op(Opcode::ADD)); // [current_ptr+32, end_ptr, size]

                // Continue loop
                self.emit_jump(loop_start);

                // Loop end - clean up stack
                self.emit_mark(loop_end);
                self.asm.push(Asm::Op(Opcode::POP)); // Remove current_ptr
                self.asm.push(Asm::Op(Opcode::POP)); // Remove end_ptr

                // Store the allocated pointer in result
                self.store_local(one_in_one.result)?;
            }

            Operation::DynamicAllocAnyBytes(one_in_one) => {
                // Allocate memory without zeroing
                // Same as DynamicAllocZeroed but without zeroing

                // Load current free memory pointer
                self.push_const(U256::from(memory::constants::FREE_MEM_PTR));
                self.asm.push(Asm::Op(Opcode::DUP1));
                self.asm.push(Asm::Op(Opcode::MLOAD));
                self.asm.push(Asm::Op(Opcode::DUP1));

                // Calculate new free pointer
                self.load_local(one_in_one.arg1)?;
                self.asm.push(Asm::Op(Opcode::ADD));

                // Store new free pointer
                self.asm.push(Asm::Op(Opcode::SWAP1));
                self.asm.push(Asm::Op(Opcode::MSTORE));

                // Store result
                self.store_local(one_in_one.result)?;
            }

            Operation::LocalAllocZeroed(one_in_one) => {
                // Same implementation as DynamicAllocZeroed
                // Could use a different memory region in the future

                self.push_const(U256::from(memory::constants::FREE_MEM_PTR));
                self.asm.push(Asm::Op(Opcode::DUP1));
                self.asm.push(Asm::Op(Opcode::MLOAD));
                self.asm.push(Asm::Op(Opcode::DUP1));

                self.load_local(one_in_one.arg1)?;
                self.asm.push(Asm::Op(Opcode::DUP1));
                self.asm.push(Asm::Op(Opcode::DUP3));
                self.asm.push(Asm::Op(Opcode::ADD));

                self.asm.push(Asm::Op(Opcode::SWAP3));
                self.asm.push(Asm::Op(Opcode::MSTORE));

                // Zero out memory with a simple loop
                let loop_start = self.marks.allocate_mark();
                let loop_end = self.marks.allocate_mark();

                self.asm.push(Asm::Op(Opcode::DUP1));
                self.asm.push(Asm::Op(Opcode::DUP3));
                self.asm.push(Asm::Op(Opcode::ADD));
                self.asm.push(Asm::Op(Opcode::SWAP1));

                self.emit_mark(loop_start);

                self.asm.push(Asm::Op(Opcode::DUP2));
                self.asm.push(Asm::Op(Opcode::DUP2));
                self.asm.push(Asm::Op(Opcode::LT));
                self.asm.push(Asm::Op(Opcode::ISZERO));
                self.emit_jumpi(loop_end);

                self.asm.push(Asm::Op(Opcode::PUSH0));
                self.asm.push(Asm::Op(Opcode::DUP2));
                self.asm.push(Asm::Op(Opcode::MSTORE));

                self.push_const(U256::from(32));
                self.asm.push(Asm::Op(Opcode::ADD));

                self.emit_jump(loop_start);

                self.emit_mark(loop_end);
                self.asm.push(Asm::Op(Opcode::POP));
                self.asm.push(Asm::Op(Opcode::POP));

                self.store_local(one_in_one.result)?;
            }

            Operation::LocalAllocAnyBytes(one_in_one) => {
                // For now, treat the same as DynamicAllocAnyBytes

                self.push_const(U256::from(memory::constants::FREE_MEM_PTR));
                self.asm.push(Asm::Op(Opcode::DUP1));
                self.asm.push(Asm::Op(Opcode::MLOAD));
                self.asm.push(Asm::Op(Opcode::DUP1));

                self.load_local(one_in_one.arg1)?;
                self.asm.push(Asm::Op(Opcode::ADD));

                self.asm.push(Asm::Op(Opcode::SWAP1));
                self.asm.push(Asm::Op(Opcode::MSTORE));

                self.store_local(one_in_one.result)?;
            }

            Operation::DynamicAllocUsingFreePointer(two_in_zero) => {
                // Takes: current free pointer and size
                // Updates free pointer to current + size

                // Load current free pointer value
                self.load_local(two_in_zero.arg1)?;

                // Add size to get new free pointer
                self.load_local(two_in_zero.arg2)?;
                self.asm.push(Asm::Op(Opcode::ADD));

                // Store new free pointer
                self.push_const(U256::from(memory::constants::FREE_MEM_PTR));
                self.asm.push(Asm::Op(Opcode::MSTORE));
            }

            // Memory operations
            Operation::MemoryLoad(load) => {
                // Load from memory with variable byte size
                self.load_local(load.address)?;

                if load.byte_size == 32 {
                    // Full word load
                    self.asm.push(Asm::Op(Opcode::MLOAD));
                } else {
                    // Partial load - load full word then mask
                    self.asm.push(Asm::Op(Opcode::MLOAD));

                    // Shift right to align bytes to the right
                    // Shift amount = (32 - byte_size) * 8
                    let shift_bits = (32 - load.byte_size as u32) * 8;
                    if shift_bits > 0 {
                        self.push_const(U256::from(shift_bits));
                        self.asm.push(Asm::Op(Opcode::SHR));
                    }
                }

                self.store_local(load.result)?;
            }

            Operation::MemoryStore(store) => {
                // Store to memory with variable byte size

                if store.byte_size == 32 {
                    // Full word store
                    self.load_local(store.value)?;
                    self.load_local(store.address)?;
                    self.asm.push(Asm::Op(Opcode::MSTORE));
                } else if store.byte_size == 1 {
                    // Single byte store
                    self.load_local(store.value)?;
                    self.load_local(store.address)?;
                    self.asm.push(Asm::Op(Opcode::MSTORE8));
                } else {
                    // Partial store - need to preserve other bytes
                    // This is complex: load existing, mask, merge, store
                    // For now, simplified version that may overwrite adjacent bytes

                    // Shift value left to align with memory position
                    self.load_local(store.value)?;
                    let shift_bits = (32 - store.byte_size as u32) * 8;
                    if shift_bits > 0 {
                        self.push_const(U256::from(shift_bits));
                        self.asm.push(Asm::Op(Opcode::SHL));
                    }
                    // Store shifted value at address
                    self.load_local(store.address)?;
                    self.asm.push(Asm::Op(Opcode::MSTORE));
                }
            }
        }

        Ok(())
    }

    /// Translate control flow at the end of a basic block
    ///
    /// Handles the various ways a basic block can transfer control:
    /// * `LastOpTerminates` - The last operation (STOP, RETURN, etc.) handles termination
    /// * `ContinuesTo` - Unconditional jump to another block
    /// * `Branches` - Conditional jump based on a boolean value
    /// * `InternalReturn` - Return from an internal function call
    /// * `Switch` - Multi-way branch based on comparing a value to multiple cases
    ///
    /// # Arguments
    /// * `control` - The control flow instruction to translate
    ///
    /// # Switch Behavior
    /// For switches without a fallback, emits a runtime error with code SWITCH_NO_MATCH
    /// if no case matches the condition value.
    fn translate_control(&mut self, control: &Control) -> Result<()> {
        match control {
            Control::LastOpTerminates => {
                // The last operation (like STOP or RETURN) handles termination
                // Nothing to do here
            }

            Control::ContinuesTo(next_block) => {
                // Unconditional jump to next block
                let next_mark = self.marks.get_block_mark(*next_block);
                self.emit_jump(next_mark);
            }

            Control::Branches(branch) => {
                // Conditional branch
                self.load_local(branch.condition)?;

                // EVM's JUMPI jumps if condition is non-zero
                let non_zero_mark = self.marks.get_block_mark(branch.non_zero_target);
                self.emit_jumpi(non_zero_mark);

                // If we didn't jump, continue to zero target
                let zero_mark = self.marks.get_block_mark(branch.zero_target);
                self.emit_jump(zero_mark);
            }

            Control::InternalReturn => {
                // TODO: Update for stack window approach
                // Load return address from memory and jump back
                // Future: Return address will be on stack
                self.push_const(U256::from(memory::constants::ZERO_SLOT));
                use evm_glue::opcodes::Opcode;
                self.asm.push(Asm::Op(Opcode::MLOAD));
                self.asm.push(Asm::Op(Opcode::JUMP));
            }

            Control::Switch(switch) => {
                use evm_glue::opcodes::Opcode;

                // Check if cases array exists
                if switch.cases.index() >= self.program.cases.len() {
                    return Err(CodegenError::InvalidCasesReference { cases: switch.cases });
                }

                // Load the condition value
                self.load_local(switch.condition)?;

                // Get number of cases
                let num_cases = self.program.cases[switch.cases].cases.len();

                // For each case: duplicate condition, push case value, compare, and jump if equal
                for i in 0..num_cases {
                    let case = &self.program.cases[switch.cases].cases[i];
                    let case_value = case.value;
                    let case_target = case.target;

                    // Stack: [condition]
                    self.asm.push(Asm::Op(Opcode::DUP1)); // Duplicate condition
                    // Stack: [condition, condition]

                    self.push_const(case_value); // Push case value
                    // Stack: [condition, condition, case_value]

                    self.asm.push(Asm::Op(Opcode::EQ)); // Compare
                    // Stack: [condition, is_equal]

                    // If equal, jump to case target
                    let case_mark = self.marks.get_block_mark(case_target);
                    self.emit_jumpi(case_mark);
                    // Stack: [condition] (after jump or continue)
                }

                // Pop the condition value (no longer needed)
                self.asm.push(Asm::Op(Opcode::POP));
                // Stack: []

                // If no case matched, jump to fallback or error
                if let Some(fallback) = switch.fallback {
                    let fallback_mark = self.marks.get_block_mark(fallback);
                    self.emit_jump(fallback_mark);
                } else {
                    // Switch without fallback - emit error code and revert
                    self.emit_runtime_error(runtime_errors::SWITCH_NO_MATCH);
                }
            }
        }

        Ok(())
    }

    // Helper methods for assembly generation

    /// Push a constant value onto the EVM stack
    ///
    /// Optimizes the push operation by using the smallest possible PUSH opcode
    /// based on the value's size. Zero values use PUSH0 (if available), small
    /// values use PUSH1-PUSH8, and larger values use PUSH32.
    ///
    /// # Arguments
    /// * `value` - The 256-bit value to push onto the stack
    ///
    /// # Optimization
    /// * 0 → PUSH0 (3 gas, post-Shanghai)
    /// * 1-255 → PUSH1 (3 gas)
    /// * 256-2^64 → PUSH2-PUSH8 (3 gas)
    /// * Larger → PUSH32 (3 gas)
    fn push_const(&mut self, value: U256) {
        use evm_glue::opcodes::Opcode;

        // Get the minimal byte representation
        if value.is_zero() {
            self.asm.push(Asm::Op(Opcode::PUSH0));
        } else {
            // Get minimal big-endian byte representation
            let trimmed = value.to_be_bytes_trimmed_vec();
            let len = trimmed.len();

            // Use the appropriate PUSH opcode based on the number of bytes
            match len {
                1 => self.asm.push(Asm::Op(Opcode::PUSH1([trimmed[0]]))),
                2 => {
                    let mut arr = [0u8; 2];
                    arr.copy_from_slice(&trimmed);
                    self.asm.push(Asm::Op(Opcode::PUSH2(arr)));
                }
                3 => {
                    let mut arr = [0u8; 3];
                    arr.copy_from_slice(&trimmed);
                    self.asm.push(Asm::Op(Opcode::PUSH3(arr)));
                }
                4 => {
                    let mut arr = [0u8; 4];
                    arr.copy_from_slice(&trimmed);
                    self.asm.push(Asm::Op(Opcode::PUSH4(arr)));
                }
                5 => {
                    let mut arr = [0u8; 5];
                    arr.copy_from_slice(&trimmed);
                    self.asm.push(Asm::Op(Opcode::PUSH5(arr)));
                }
                6 => {
                    let mut arr = [0u8; 6];
                    arr.copy_from_slice(&trimmed);
                    self.asm.push(Asm::Op(Opcode::PUSH6(arr)));
                }
                7 => {
                    let mut arr = [0u8; 7];
                    arr.copy_from_slice(&trimmed);
                    self.asm.push(Asm::Op(Opcode::PUSH7(arr)));
                }
                8 => {
                    let mut arr = [0u8; 8];
                    arr.copy_from_slice(&trimmed);
                    self.asm.push(Asm::Op(Opcode::PUSH8(arr)));
                }
                // For larger values, just use PUSH32 with full bytes
                _ => {
                    let arr: [u8; 32] = value.to_be_bytes();
                    self.asm.push(Asm::Op(Opcode::PUSH32(arr)));
                }
            }
        }
    }

    /// Validate that a range of locals exists in the program
    ///
    /// Used by operations that access multiple consecutive locals (e.g., CALL operations
    /// that need 7 locals for gas, address, value, and data parameters).
    ///
    /// # Arguments
    /// * `start` - The starting index in the locals array
    /// * `required` - The number of consecutive locals needed
    ///
    /// # Errors
    /// Returns `InvalidLocalRange` if the range [start, start+required) exceeds the locals array
    fn validate_local_range(&self, start: usize, required: usize) -> Result<()> {
        let end = start + required;
        if end > self.program.locals.len() {
            return Err(CodegenError::InvalidLocalRange {
                range: start..end,
                locals_len: self.program.locals.len(),
            });
        }
        Ok(())
    }

    /// Load a local variable from memory onto the EVM stack
    ///
    /// Retrieves the value of a local variable from its allocated memory location
    /// and pushes it onto the stack. Each local has a dedicated 32-byte slot in memory
    /// starting at address 0x80.
    ///
    /// # Arguments
    /// * `local` - The ID of the local variable to load
    ///
    /// # Stack Effects
    /// * Before: []
    /// * After: [value]
    ///
    /// # Errors
    /// Returns `LocalNotFound` if the local hasn't been allocated in memory
    fn load_local(&mut self, local: LocalId) -> Result<()> {
        use evm_glue::opcodes::Opcode;

        if let Some(addr) = self.memory.get_local_address(local) {
            // Push memory address
            self.push_const(U256::from(addr));
            // Load from memory
            self.asm.push(Asm::Op(Opcode::MLOAD));
            Ok(())
        } else {
            Err(CodegenError::LocalNotFound { local })
        }
    }

    /// Store a value from the EVM stack to a local variable in memory
    ///
    /// Takes the top value from the stack and stores it in the allocated memory
    /// location for the specified local variable.
    ///
    /// # Arguments
    /// * `local` - The ID of the local variable to store to
    ///
    /// # Stack Effects
    /// * Before: [value]
    /// * After: []
    ///
    /// # Memory Effects
    /// Writes 32 bytes to the local's memory address
    ///
    /// # Errors
    /// Returns `LocalNotFound` if the local hasn't been allocated in memory
    fn store_local(&mut self, local: LocalId) -> Result<()> {
        use evm_glue::opcodes::Opcode;

        if let Some(addr) = self.memory.get_local_address(local) {
            // Stack: [value]
            // Push memory address
            self.push_const(U256::from(addr));
            // Stack: [value, addr]
            self.asm.push(Asm::Op(Opcode::MSTORE));
            Ok(())
        } else {
            Err(CodegenError::LocalNotFound { local })
        }
    }

    /// Emit a mark (jump label) at the current position in the assembly
    ///
    /// Creates a jump destination that can be referenced by JUMP and JUMPI instructions.
    /// Every jump target in EVM must be preceded by a JUMPDEST opcode.
    ///
    /// # Arguments
    /// * `mark_id` - The unique identifier for this jump destination
    ///
    /// # Assembly Output
    /// 1. Mark(mark_id) - Metadata for evm-glue to resolve jump addresses
    /// 2. JUMPDEST - Required EVM opcode at all jump targets
    fn emit_mark(&mut self, mark_id: MarkId) {
        use evm_glue::opcodes::Opcode;

        // Emit the mark for evm-glue to track
        self.asm.push(Asm::Mark(mark_id));

        // Emit JUMPDEST opcode - required by EVM at jump targets
        self.asm.push(Asm::Op(Opcode::JUMPDEST));
    }

    /// Emit an unconditional jump to a marked location
    ///
    /// Generates code to jump to a previously or subsequently defined mark.
    /// The actual address is resolved by evm-glue during assembly.
    ///
    /// # Arguments
    /// * `mark_id` - The mark to jump to
    ///
    /// # Stack Effects
    /// * Before: []
    /// * After: [] (JUMP consumes the destination address)
    fn emit_jump(&mut self, mark_id: MarkId) {
        use evm_glue::opcodes::Opcode;

        // Push the mark reference
        self.asm.push(Asm::Ref(MarkRef {
            ref_type: RefType::Direct(mark_id),
            is_pushed: true,
            set_size: None,
        }));
        // Jump to it
        self.asm.push(Asm::Op(Opcode::JUMP));
    }

    /// Emit a conditional jump to a marked location
    ///
    /// Jumps to the mark if the condition on the stack is non-zero.
    /// If the condition is zero, execution continues to the next instruction.
    ///
    /// # Arguments
    /// * `mark_id` - The mark to jump to if condition is true
    ///
    /// # Stack Effects
    /// * Before: [condition]
    /// * After: [] (JUMPI consumes both condition and destination)
    ///
    /// # Jump Behavior
    /// * condition != 0 → jump to mark
    /// * condition == 0 → continue to next instruction
    fn emit_jumpi(&mut self, mark_id: MarkId) {
        use evm_glue::opcodes::Opcode;

        // Stack should have: [condition]
        // Push the mark reference
        self.asm.push(Asm::Ref(MarkRef {
            ref_type: RefType::Direct(mark_id),
            is_pushed: true,
            set_size: None,
        }));
        // Stack: [condition, destination]
        // Conditional jump
        self.asm.push(Asm::Op(Opcode::JUMPI));
    }

    /// Emit a runtime error with a specific error code
    ///
    /// This stores the error code in memory and reverts with it as return data.
    /// The error code is stored at memory address 0x00 (scratch space).
    fn emit_runtime_error(&mut self, error_code: u8) {
        use evm_glue::opcodes::Opcode;

        // Store error code at memory address 0x00
        self.push_const(U256::from(error_code));
        self.push_const(U256::from(0x00));
        self.asm.push(Asm::Op(Opcode::MSTORE8));

        // REVERT with the error code
        // offset = 0x00, size = 1
        self.push_const(U256::from(1)); // size
        self.push_const(U256::from(0)); // offset
        self.asm.push(Asm::Op(Opcode::REVERT));
    }
}

/// High-level function to translate an IR program to EVM assembly
pub fn translate_program(program: EthIRProgram) -> Result<Vec<Asm>> {
    let mut translator = Translator::new(program);
    translator.translate()?;
    Ok(translator.into_asm())
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::test_helpers::*;
    use eth_ir_data::{operation::*, *};

    // ==================== Basic Translation ====================

    #[test]
    fn test_internal_operations() {
        // Test operations that are IR-specific (not direct EVM opcodes)
        let operations = vec![
            Operation::LocalSet(OneInOneOut { result: LocalId::new(1), arg1: LocalId::new(0) }),
            Operation::NoOp,
            Operation::RuntimeStartOffset(ZeroInOneOut { result: LocalId::new(2) }),
            Operation::InitEndOffset(ZeroInOneOut { result: LocalId::new(3) }),
            Operation::RuntimeLength(ZeroInOneOut { result: LocalId::new(4) }),
            Operation::Stop,
        ];

        let program = create_simple_program(operations);
        let asm = translate_program(program).expect("Translation should succeed");

        // Initialization: 1 MSTORE for free memory pointer
        // LocalSet: 1 MLOAD + 1 MSTORE
        // RuntimeStartOffset, InitEndOffset, RuntimeLength: 3 MSTORE
        // Total: 5 MSTORE, 1 MLOAD
        assert_opcode_counts(&asm, &[("MSTORE", 5), ("MLOAD", 1), ("STOP", 1)]);
    }

    // ==================== Control Flow ====================

    #[test]
    fn test_control_flow() {
        // Test branching and switches together
        let blocks = vec![
            (
                vec![Operation::LocalSetSmallConst(SetSmallConst {
                    local: LocalId::new(0),
                    value: 1,
                })],
                Control::Branches(Branch {
                    condition: LocalId::new(0),
                    zero_target: BasicBlockId::new(1),
                    non_zero_target: BasicBlockId::new(2),
                }),
            ),
            (vec![Operation::Stop], Control::LastOpTerminates),
            (vec![Operation::Stop], Control::LastOpTerminates),
        ];

        let program = create_branching_program(blocks, 1);
        let asm = translate_program(program).expect("Translation should succeed");

        // One branch generates one JUMPI for the conditional jump
        // Three blocks + init function entry = 4 JUMPDEST labels
        assert_opcode_counts(&asm, &[("JUMPI", 1), ("JUMPDEST", 4)]);
    }

    // ==================== Deployment ====================

    #[test]
    fn test_deployment() {
        // Test deployment patterns
        let program = EthIRProgram {
            init_entry: FunctionId::new(0),
            main_entry: Some(FunctionId::new(1)),
            functions: index_vec![
                Function { entry: BasicBlockId::new(0), outputs: 0 },
                Function { entry: BasicBlockId::new(1), outputs: 0 },
            ],
            basic_blocks: index_vec![
                BasicBlock {
                    inputs: LocalIndex::from_usize(0)..LocalIndex::from_usize(0),
                    outputs: LocalIndex::from_usize(0)..LocalIndex::from_usize(0),
                    operations: OperationIndex::from_usize(0)..OperationIndex::from_usize(1),
                    control: Control::LastOpTerminates,
                },
                BasicBlock {
                    inputs: LocalIndex::from_usize(0)..LocalIndex::from_usize(0),
                    outputs: LocalIndex::from_usize(0)..LocalIndex::from_usize(0),
                    operations: OperationIndex::from_usize(1)..OperationIndex::from_usize(2),
                    control: Control::LastOpTerminates,
                },
            ],
            operations: index_vec![Operation::Stop, Operation::Stop],
            locals: index_vec![],
            data_segments_start: index_vec![],
            data_bytes: index_vec![],
            large_consts: index_vec![],
            cases: index_vec![],
        };

        let asm = translate_program(program).expect("Translation should succeed");
        // Deployment should have CODECOPY to copy runtime code and RETURN to return it
        assert_opcode_counts(&asm, &[("CODECOPY", 1), ("RETURN", 1), ("STOP", 2)]);
    }

    // ==================== Error Conditions ====================

    #[test]
    fn test_empty_program() {
        // Test that empty programs translate successfully
        let program = create_simple_program(vec![]);
        let asm = translate_program(program).expect("Empty program should translate");

        // Should still have deployment code
        assert_opcode_counts(&asm, &[("CODECOPY", 1), ("RETURN", 1)]);
    }

    #[test]
    fn test_program_with_only_noop() {
        // Test program with only NoOp operations
        let operations = vec![Operation::NoOp, Operation::NoOp, Operation::NoOp, Operation::Stop];

        let program = create_simple_program(operations);
        let asm = translate_program(program).expect("NoOp program should translate");

        // NoOps should not generate any opcodes
        assert_eq!(count_opcode(&asm, "STOP"), 1);
    }

    #[test]
    fn test_large_local_ids() {
        // Test handling of large local IDs
        const LARGE_LOCAL_ID: u32 = 1000;
        let operations = vec![
            Operation::LocalSetSmallConst(SetSmallConst {
                local: LocalId::new(LARGE_LOCAL_ID),
                value: 42,
            }),
            Operation::LocalSet(OneInOneOut {
                result: LocalId::new(LARGE_LOCAL_ID + 1),
                arg1: LocalId::new(LARGE_LOCAL_ID),
            }),
            Operation::Stop,
        ];

        let program = create_simple_program(operations);
        let asm = translate_program(program).expect("Large local IDs should be handled");

        // Should generate MSTORE operations for the large local IDs
        assert!(count_opcode(&asm, "MSTORE") >= 3); // init + 2 locals
    }

    #[test]
    fn test_deeply_nested_blocks() {
        // Test deeply nested control flow blocks
        let blocks = vec![
            (
                vec![Operation::LocalSetSmallConst(SetSmallConst {
                    local: LocalId::new(0),
                    value: 1,
                })],
                Control::ContinuesTo(BasicBlockId::new(1)),
            ),
            (
                vec![Operation::LocalSetSmallConst(SetSmallConst {
                    local: LocalId::new(1),
                    value: 2,
                })],
                Control::ContinuesTo(BasicBlockId::new(2)),
            ),
            (
                vec![Operation::LocalSetSmallConst(SetSmallConst {
                    local: LocalId::new(2),
                    value: 3,
                })],
                Control::ContinuesTo(BasicBlockId::new(3)),
            ),
            (vec![Operation::Stop], Control::LastOpTerminates),
        ];

        let program = create_branching_program(blocks, 3);
        let asm = translate_program(program).expect("Deeply nested blocks should translate");

        // Should have JUMPDEST for each block plus init
        assert!(count_opcode(&asm, "JUMPDEST") >= 4);
    }
}
